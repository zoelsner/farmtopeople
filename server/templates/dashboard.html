<!DOCTYPE html>
<!--
    =========================================================================
    FARM TO PEOPLE DASHBOARD - MAIN USER INTERFACE
    =========================================================================

    FILE STRUCTURE:
    ---------------
    1. HEAD (Lines 1-1050)
       - Meta tags for PWA support
       - CSS imports (fitbod_meal_planning.css)
       - Inline styles for light theme overrides
       - Navigation tabs and loading states

    2. HTML STRUCTURE (Lines 1050-1450)
       - Header with title and delivery date
       - Bottom navigation tabs (Cart, Meals, Settings)
       - Cart Tab: Analysis screen, loading states, results display
       - Meals Tab: Weekly calendar, drag-and-drop meal planning
       - Settings Tab: User preferences (NOW OPENS AS MODAL - PWA FIX)

    3. JAVASCRIPT SECTIONS (Lines 1450-3500+)
       - Cart Analysis Functions (Lines 1450-2000)
         * analyzeCart() - Main cart scraping function
         * showCartAnalysis() - Display cart results
         * generateMealSuggestions() - AI meal recommendations

       - Tab Navigation (Lines 2448-2515)
         * switchTab() - Handle tab switching (Settings ‚Üí Modal)
         * openSettingsModal() - NEW: Open settings in overlay (Line 2516)
         * closeSettingsModal() - NEW: Close settings overlay (Line 2708)

       - Meal Calendar (Lines 2680-3000)
         * initMealCalendar() - Setup weekly view
         * Drag and drop handlers
         * Meal regeneration

       - Settings Management (Lines 3340-3500)
         * loadUserSettings() - Fetch user preferences
         * displaySettings() - Render settings UI
         * savePreferences() - Update user data

    RECENT CHANGES (Sept 2025):
    ---------------------------
    - Settings tab now opens as modal overlay (PWA navigation fix)
    - Added openSettingsModal() and closeSettingsModal() functions
    - Settings no longer causes page refresh in PWA mode

    KEY FEATURES:
    -------------
    - Progressive Web App (PWA) compatible
    - Real-time cart analysis from Farm to People
    - AI-powered meal suggestions based on cart contents
    - Drag-and-drop meal calendar for weekly planning
    - User preference management
    - Offline-capable with localStorage fallbacks

    API ENDPOINTS USED:
    -------------------
    - POST /api/analyze-cart - Scrape and analyze FTP cart
    - GET /api/settings/{phone} - Load user preferences
    - POST /api/update-preferences - Save preference changes
    - POST /api/generate-weekly-meals - Create meal plan
    - GET /api/meal-plans/{phone}/{week} - Load saved meal plans

    =========================================================================
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>Your Meal Plan - Farm to People</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <!-- Professional Fitbod CSS for styling only -->
    <link rel="stylesheet" href="/static/css/fitbod_meal_planning.css">

    <!-- Dashboard-specific styles (extracted for maintainability) -->
    <link rel="stylesheet" href="/static/css/dashboard-styles.css?v=20250918-grid-fix">

</head>
<body>
    <div class="header">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h1 style="font-size: 20px;">Cart Analysis</h1>
                <p class="subtitle" id="headerSubtitle">Ready to analyze your cart</p>
            </div>
            <div id="deliveryDate" style="display: none; text-align: right;">
                <div style="color: #28a745; font-weight: 600; font-size: 16px;" id="deliveryDateText"></div>
                <div style="color: #6c757d; font-size: 12px;">Delivery Date</div>
            </div>
        </div>
    </div>

    <div class="content">
        <!-- Box Tab Content -->
        <div class="tab-content active" id="boxTab">
            <!-- Start Screen - Shows First -->
            <div class="start-screen section active" id="startSection">
            <div class="start-icon">üì¶</div>
            <h2 class="start-title" style="font-size: 20px;">Cart Analysis</h2>
            <p class="start-description">
                See what's in your Farm to People cart, suggested swaps, and add-ons.
            </p>
            <button class="analyze-button" onclick="FarmDashboard.Cart.startAnalysis()">
                Analyze My Cart
            </button>
        </div>

        <!-- Loading Screen - Shows During Analysis -->
        <div class="loading-screen section" id="loadingSection">
            <div class="loading-animation"></div>
            <h2 class="loading-title">Analyzing Your Cart</h2>
            <p class="loading-status" id="loadingStatus">Logging into Farm to People...</p>
            
            <div class="loading-tip">
                <h3>While you wait (20-30 seconds)</h3>
                <p>Add this page to your home screen for easy access:</p>
                <button class="home-screen-prompt" onclick="showAddToHomeScreen()">
                    Add to Home Screen
                </button>
            </div>
        </div>

        <!-- Cart Analysis Display - Shows After Analysis -->
        <div class="cart-analysis section" id="cartAnalysisSection">
            <!-- Suggested Meals - TOP PRIORITY -->
            <div class="cart-section" id="suggestedMealsSection">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h3 class="section-header" style="margin: 0;">Suggested Meals</h3>
                    <div style="display: flex; gap: 8px;">
                        <button id="refreshSuggestionsButton" onclick="refreshSuggestions()"
                                style="background: #faf8f2; color: #07261e; border: 1px solid #e6d8b5; border-radius: 8px; padding: 6px 14px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f3a208'" onmouseout="this.style.background='#faf8f2'">
                            ‚ú® New Suggestions
                        </button>
                        <button id="refreshCartButton" onclick="FarmDashboard.Cart.refreshCartData()"
                                style="background: #faf8f2; color: #07261e; border: 1px solid #e6d8b5; border-radius: 8px; padding: 6px 14px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f3a208'" onmouseout="this.style.background='#faf8f2'">
                            üîÑ Refresh Cart
                        </button>
                    </div>
                </div>
                <div id="suggestedMeals">
                    <!-- Suggested meals based on preferences will be inserted here -->
                </div>
            </div>

            <!-- Smart Swaps - MOVED UP for better visibility -->
            <div class="cart-section" id="swapsSection">
                <h3 class="section-header">
                    üîÑ Smart Swaps
                    <span style="font-size: 14px; color: #666; font-weight: normal; margin-left: 8px;">
                        (Based on your preferences)
                    </span>
                </h3>
                <div id="suggestedSwaps">
                    <!-- Swap suggestions will be inserted here -->
                </div>
            </div>

            <!-- Premium Add-Ons - MOVED HERE for logical flow: Meals ‚Üí Swaps ‚Üí Add-ons -->
            <div class="cart-section" id="addonsSection">
                <h3 class="section-header" style="display: flex; align-items: center;">
                    <span style="font-size: 20px; margin-right: 8px;">+</span> Premium Add-Ons
                </h3>
                <div id="recommendedAddons">
                    <!-- Add-on recommendations will be inserted here -->
                </div>
            </div>

            <!-- Cart Summary -->
            <div id="cartSummary" style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px; padding: 0 20px;">
                <!-- Summary counts will be inserted here -->
            </div>

            <!-- Individual Items -->
            <div class="cart-section" id="individualItemsSection">
                <h3 class="section-header">
                    Individual Items <span id="individualItemsCount" style="color: #666; font-weight: normal; font-size: 16px;"></span>
                </h3>
                <div class="item-grid" id="individualItems">
                    <!-- Individual items will be inserted here -->
                </div>
            </div>

            <!-- Customizable Boxes -->
            <div class="cart-section" id="customizableBoxesSection">
                <h3 class="section-header">
                    Customizable Boxes <span id="customizableBoxesCount" style="color: #666; font-weight: normal; font-size: 16px;"></span>
                </h3>
                <div id="customizableBoxes">
                    <!-- Customizable box data will be inserted here -->
                </div>
            </div>

            <!-- Non-Customizable Boxes -->
            <div class="cart-section" id="nonCustomizableBoxesSection">
                <h3 class="section-header">
                    Fixed Boxes <span id="fixedBoxesCount" style="color: #666; font-weight: normal; font-size: 16px;"></span>
                </h3>
                <div id="nonCustomizableBoxes">
                    <!-- Non-customizable box data will be inserted here -->
                </div>
            </div>
        </div>
        </div> <!-- End Box Tab -->

        <!-- Plan Tab Content -->
        <div class="tab-content" id="planTab">
            <!-- Meals View - Weekly Meal Calendar -->
            <div class="meals-view section active" id="mealsSection">
            <div class="calendar-header">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <div>
                        <h2 style="margin: 0; font-size: 20px; font-weight: 600; color: #1a1a1a;">This Week's Meals</h2>
                        <!-- Removed subtitle "Plan your Sunday-Thursday dinners" to reduce clutter -->
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <!-- Week navigation hidden for now - showing only current delivery week -->
                        <button id="prevWeek" class="nav-button" style="display: none;">‚Äπ</button>
                        <button id="nextWeek" class="nav-button" style="display: none;">‚Ä∫</button>
                        <button id="generatePDF" class="pdf-button" style="display: none;">üìÑ PDF</button>
                    </div>
                </div>
            </div>

            <!-- Loading state -->
            <div id="mealPlanLoading" class="loading-state" style="display: none;">
                <div class="spinner"></div>
                <p>Loading your meal plan...</p>
            </div>

            <!-- Error state -->
            <div id="mealPlanError" class="error-state" style="display: none;">
                <div class="error-icon">‚ö†Ô∏è</div>
                <p>Unable to load meal plan</p>
                <button id="retryLoad" class="retry-button">Try Again</button>
            </div>

            <!-- Meal Locking Interface - NEW -->
            <div id="simpleMealCardContainer" class="meal-locking-container" style="display: block;">
                <!-- Meal Suggestions (4 cards that can be locked) -->
                <div class="meal-suggestions-header">
                    <h3>üçΩÔ∏è Suggested Meals</h3>
                    <button id="generateMealsButton" class="regenerate-button" onclick="generateMealSuggestions()"
                            style="background: #faf8f2; color: #07261e; border: 1px solid #e6d8b5; border-radius: 8px; padding: 6px 14px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f3a208'" onmouseout="this.style.background='#faf8f2'">
                        üîÑ New Suggestions
                    </button>
                </div>

                <!-- Weekly Summary Bar -->
                <div id="weeklySummaryBar" style="background: #f8fafb; border: 1px solid #e5e7eb; border-radius: 8px; padding: 12px 16px; margin-bottom: 16px; display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px;">
                        <div style="display: flex; gap: 16px; font-size: 13px; color: #6b7280; font-weight: 500;">
                            <span id="summaryMealCount">5 meals</span>
                            <span id="summaryProtein">155g protein</span>
                            <span id="summaryTime">Avg 28 min</span>
                        </div>
                        <button id="generateShoppingListBtn" style="background: #f9fafb; border: 1px solid #d1d5db; border-radius: 6px; padding: 4px 12px; font-size: 12px; color: #374151; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='#f9fafb'">
                            üìù Shopping List
                        </button>
                    </div>
                </div>

                <div id="mealSuggestionsGrid" class="meal-suggestions-grid">
                    <!-- 4 meal suggestion cards will be populated here -->
                </div>

                <!-- Locked Meals Section - REMOVED to eliminate competing views -->

                <!-- Action buttons - REMOVED: Create Full Week Plan button was redundant -->
            </div>

            <!-- Empty state -->
            <div id="mealPlanEmpty" class="empty-state" style="display: none;">
                <div class="empty-content" id="noMealsPlaceholder">
                    <h3>No Meals Yet</h3>
                    <p>Analyze your cart to see personalized meal recommendations...</p>
                    <div class="spinner" style="margin: 20px auto;"></div>
                </div>
            </div>

            <!-- Main Calendar Grid -->
            <div id="mealCalendarGrid" class="calendar-container" style="display: none;">
                <!-- Calendar Days (Vertical Layout) -->
                <div class="calendar-grid">
                    <div class="day-row" data-day="monday">
                        <div class="day-header">
                            <h3>Mon</h3>
                            <span class="day-date" id="monday-date"></span>
                        </div>
                        <div class="meal-slot" data-day="monday">
                            <div class="add-meal-prompt">
                                <span class="add-icon">+</span>
                                <span>Add Meal</span>
                            </div>
                        </div>
                    </div>

                    <div class="day-row" data-day="tuesday">
                        <div class="day-header">
                            <h3>Tue</h3>
                            <span class="day-date" id="tuesday-date"></span>
                        </div>
                        <div class="meal-slot" data-day="tuesday">
                            <div class="add-meal-prompt">
                                <span class="add-icon">+</span>
                                <span>Add Meal</span>
                            </div>
                        </div>
                    </div>

                    <div class="day-row" data-day="wednesday">
                        <div class="day-header">
                            <h3>Wed</h3>
                            <span class="day-date" id="wednesday-date"></span>
                        </div>
                        <div class="meal-slot" data-day="wednesday">
                            <div class="add-meal-prompt">
                                <span class="add-icon">+</span>
                                <span>Add Meal</span>
                            </div>
                        </div>
                    </div>

                    <div class="day-row" data-day="thursday">
                        <div class="day-header">
                            <h3>Thu</h3>
                            <span class="day-date" id="thursday-date"></span>
                        </div>
                        <div class="meal-slot" data-day="thursday">
                            <div class="add-meal-prompt">
                                <span class="add-icon">+</span>
                                <span>Add Meal</span>
                            </div>
                        </div>
                    </div>

                    <div class="day-row" data-day="friday">
                        <div class="day-header">
                            <h3>Fri</h3>
                            <span class="day-date" id="friday-date"></span>
                        </div>
                        <div class="meal-slot" data-day="friday">
                            <div class="add-meal-prompt">
                                <span class="add-icon">+</span>
                                <span>Add Meal</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Ingredient Pool Sidebar - Hidden for simplicity -->
                <div class="ingredient-panel" style="display: none;">
                    <h3>Ingredient Pool</h3>
                    <div id="ingredientList" class="ingredient-list">
                        <!-- Ingredients will be loaded here -->
                    </div>
                    <div class="panel-actions">
                        <button id="autoFillWeek" class="auto-fill-button">üéØ Auto-Fill Week</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings -->
        <!-- Settings are now handled via modal overlay - no longer need section here -->
    </div>

    <!-- Bottom Tab Navigation -->
    <nav class="bottom-tabs">
        <a href="#cart" class="tab active" onclick="switchTab('cart', this); return false;">
            <svg class="tab-icon icon-cart" viewBox="0 0 24 24">
                <circle cx="8" cy="21" r="1"/>
                <circle cx="19" cy="21" r="1"/>
                <path d="m2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12"/>
            </svg>
            <span class="tab-label">Cart</span>
        </a>
        <a href="#meals" class="tab" onclick="switchTab('meals', this); return false;">
            <svg class="tab-icon icon-meals" viewBox="0 0 24 24">
                <path d="M8.1 13.34l2.83-2.83L3.91 3.5c-1.56 1.56-1.56 4.09 0 5.66l4.19 4.18zm6.78-1.81c1.53.71 3.68.21 5.27-1.38 1.91-1.91 2.28-4.65.81-6.12-1.46-1.46-4.2-1.1-6.12.81-1.59 1.59-2.09 3.74-1.38 5.27L3.7 19.87l1.41 1.41L12 14.41l6.88 6.88 1.41-1.41L13.41 11.73z"/>
            </svg>
            <span class="tab-label">Meals</span>
        </a>
        <a href="#settings" class="tab" onclick="switchTab('settings', this); return false;">
            <svg class="tab-icon icon-settings" viewBox="0 0 24 24">
                <path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>
            </svg>
            <span class="tab-label">Settings</span>
        </a>
    </nav>

    <script>
        // ===== FARM DASHBOARD NAMESPACE (Sept 2025) =====
        // Organizing all dashboard functionality into logical groups
        // for maintainability and future meal locking features

        const FarmDashboard = {
            // Centralized state management (replacing scattered globals)
            state: {
                currentState: 'start', // start, loading, complete
                mealPlanData: null,
                refreshesLeft: 3,
                userEmail: null,
                userPhone: null,
                cartData: null,
                mealSuggestions: [],
                deliveryDate: null,

                // Timer management
                statusInterval: null,
                analysisTimeout: null,
                isAnalyzing: false,
                lastMealGenerationTime: 0,
                mealGenerationTimeoutId: null,
                mealGenerationInProgress: false
            },

            // Initialize dashboard
            init: function() {
                console.log('üöÄ Initializing FarmDashboard...');
                this.Utils.clearStaleCache();
                this.Cart.init();
                this.Meals.init();
                this.Settings.init();
                // this.MealLocking.init(); // DISABLED: Causes competing views - only use clean card view with simple lock emojis
            },

            // Utility functions
            Utils: {
                // Clear stale cache data to prevent cross-user contamination
                clearStaleCache: function() {
                    const currentUser = localStorage.getItem('ftpEmail');
                    const lastUser = localStorage.getItem('lastLoggedInUser');

                    if (currentUser && currentUser !== lastUser) {
                        console.log('Different user detected, clearing cache...');
                        localStorage.removeItem('cartAnalysisData');
                        localStorage.removeItem('cartAnalysisState');
                        localStorage.removeItem('cachedMealSuggestions');
                        localStorage.removeItem('cachedMealSuggestionsTimestamp');
                        localStorage.removeItem('refreshesLeft');
                        localStorage.setItem('lastLoggedInUser', currentUser);
                    }
                },

                // Get phone number from various sources
                getPhoneNumber: function() {
                    const urlParams = new URLSearchParams(window.location.search);
                    return urlParams.get('phone') ||
                           localStorage.getItem('userPhone') ||
                           FarmDashboard.state.userPhone ||
                           '';
                },

                // Format phone number for display
                formatPhoneNumber: function(phone) {
                    if (!phone) return '';
                    // Format as (XXX) XXX-XXXX
                    const cleaned = phone.replace(/\D/g, '');
                    const match = cleaned.match(/^(\d{3})(\d{3})(\d{4})$/);
                    return match ? `(${match[1]}) ${match[2]}-${match[3]}` : phone;
                },

                // Clear all analysis timers
                clearAnalysisTimers: function() {
                    if (FarmDashboard.state.statusInterval) {
                        clearInterval(FarmDashboard.state.statusInterval);
                        FarmDashboard.state.statusInterval = null;
                    }
                    if (FarmDashboard.state.analysisTimeout) {
                        clearTimeout(FarmDashboard.state.analysisTimeout);
                        FarmDashboard.state.analysisTimeout = null;
                    }
                    if (FarmDashboard.state.mealGenerationTimeoutId) {
                        clearTimeout(FarmDashboard.state.mealGenerationTimeoutId);
                        FarmDashboard.state.mealGenerationTimeoutId = null;
                    }
                },

                // Debouncing helper for meal generation
                debounceMealGeneration: function(func, timeout = 500) {
                    return function(...args) {
                        const now = Date.now();
                        if (now - FarmDashboard.state.lastMealGenerationTime < timeout) {
                            console.log('üö´ Meal generation debounced');
                            return;
                        }
                        FarmDashboard.state.lastMealGenerationTime = now;
                        return func.apply(this, args);
                    };
                },

                // Show toast notification (new utility)
                showToast: function(message, type = 'info') {
                    // Simple toast implementation for user feedback
                    const toast = document.createElement('div');
                    toast.className = `toast toast-${type}`;
                    toast.textContent = message;
                    toast.style.cssText = `
                        position: fixed; top: 20px; right: 20px; z-index: 10000;
                        background: ${type === 'error' ? '#dc3545' : type === 'success' ? '#28a745' : '#007AFF'};
                        color: white; padding: 12px 20px; border-radius: 8px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.2); font-weight: 500;
                        animation: fadeIn 0.3s ease;
                    `;
                    document.body.appendChild(toast);
                    setTimeout(() => {
                        toast.style.animation = 'fadeOut 0.3s ease';
                        setTimeout(() => document.body.removeChild(toast), 300);
                    }, 3000);
                }
            },

            // Cart analysis functionality
            Cart: {
                // Initialize cart functionality
                init: function() {
                    console.log('üõí Initializing Cart module...');
                    // Auto-load saved cart data on page load
                    if (typeof loadSavedCartData === 'function') {
                        loadSavedCartData().then(loaded => {
                            if (!loaded) {
                                console.log('‚ÑπÔ∏è No saved cart - ready for analysis');
                            }
                        });
                    }
                    restoreCartLockTime();
                },

                // Delegate to legacy loadSavedCartData function
                loadSavedCartData: async function() {
                    return await loadSavedCartData();
                },

                // Delegate to legacy startAnalysis function
                startAnalysis: async function(forceRefresh = false) {
                    return await startAnalysis(forceRefresh);
                },

                // Refresh meal display with lock status
                refreshMealDisplay: async function() {
                    // Get current meals from cache
                    const cachedMeals = localStorage.getItem('cachedMealSuggestions');
                    if (cachedMeals) {
                        try {
                            const meals = JSON.parse(cachedMeals);
                            // Sync lock status from Redis first
                            await FarmDashboard.MealLocking.syncFromRedis();
                            // Update meal display with lock indicators
                            updateMealSuggestions(meals);
                        } catch (e) {
                            console.log('‚ö†Ô∏è Could not refresh meal display with locks:', e);
                        }
                    }
                },

                // Delegate to legacy showCartAnalysis function
                showAnalysis: function(cartData, swaps = [], addons = [], freshScrape = false, cachedMeals = null) {
                    return showCartAnalysis(cartData, swaps, addons, freshScrape, cachedMeals);
                },

                // Delegate to legacy refreshCartData function
                refreshCartData: async function() {
                    return await refreshCartData();
                },

                // Delegate to legacy restoreCartLockTime function
                restoreCartLockTime: function() {
                    return restoreCartLockTime();
                }
            },

            // Meal planning functionality
            Meals: {
                // Initialize meals functionality
                init: function() {
                    console.log('üçΩÔ∏è Initializing Meals module...');
                    // No delegation needed - meals initialize through other paths
                },

                // Delegate to legacy syncMealsFromCart function
                syncFromCart: function() {
                    return syncMealsFromCart();
                },

                // Delegate to legacy populateSimpleMealCard function
                populateCard: function(meal) {
                    return populateSimpleMealCard(meal);
                },

                // Delegate to legacy toggleMealLock function
                toggleLock: function(mealIndex) {
                    // Delegate to MealLocking namespace
                    return FarmDashboard.MealLocking.toggleLock(mealIndex);
                },

                // Keep existing regenerate function (already implemented)
                regenerate: async function() {
                    console.log('üîÑ Regenerating meal suggestions...');

                    try {
                        const phone = FarmDashboard.Utils.getPhoneNumber();
                        if (!phone) {
                            console.error('‚ùå No phone number found for regeneration');
                            return;
                        }

                        const response = await fetch('/api/refresh-meals', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ phone: phone })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            if (data.meals && data.meals.length > 0) {
                                FarmDashboard.state.mealSuggestions = data.meals;
                                this.populateCard(data.meals[0]);
                                FarmDashboard.Utils.showToast('Meals regenerated!', 'success');
                            }
                        }
                    } catch (error) {
                        console.error('‚ùå Error regenerating meals:', error);
                        FarmDashboard.Utils.showToast('Failed to regenerate meals', 'error');
                    }
                }
            },

            // Settings management
            Settings: {
                // Initialize settings functionality
                init: function() {
                    console.log('‚öôÔ∏è Initializing Settings module...');
                    // Settings already handled via iframe modal - works perfectly!
                },

                // Open settings modal (iframe approach - PWA friendly)
                openModal: function() {
                    console.log('üîß Opening settings modal via iframe...');
                    // Call the existing openSettingsModal function
                    if (typeof openSettingsModal === 'function') {
                        openSettingsModal();
                    }
                },

                // Close settings modal
                closeModal: function() {
                    console.log('üîß Closing settings modal...');
                    // Call the existing closeSettingsModal function
                    if (typeof closeSettingsModal === 'function') {
                        closeSettingsModal();
                    }
                }
            },

            // NEW: Meal locking functionality
            MealLocking: {
                // State for meal locking
                state: {
                    locked: [false, false, false, false, false],
                    version: 0,
                    syncTimer: null
                },

                // Initialize meal locking
                init: function() {
                    console.log('üîí Initializing Meal Locking module...');
                    this.setupSync();
                },

                // Toggle lock for a specific meal
                toggleLock: async function(index) {
                    console.log(`üîí Toggling lock for meal ${index}`);

                    // Optimistic UI update
                    const isLocked = !this.state.locked[index];
                    this.state.locked[index] = isLocked;
                    this.updateLockUI(index, isLocked);

                    try {
                        // Sync to Redis
                        await this.syncToRedis(index, isLocked);

                        // Show feedback
                        FarmDashboard.Utils.showToast(
                            isLocked ? 'Meal locked!' : 'Meal unlocked!',
                            'success'
                        );

                        // Update Cart tab on next focus
                        this.markCartTabStale();

                    } catch (error) {
                        // Revert on failure
                        this.state.locked[index] = !isLocked;
                        this.updateLockUI(index, !isLocked);
                        FarmDashboard.Utils.showToast('Failed to save lock', 'error');
                        console.error('‚ùå Lock sync failed:', error);
                    }
                },

                // Update UI for a specific lock
                updateLockUI: function(index, locked) {
                    const card = document.querySelector(`[data-meal-index="${index}"]`);
                    const lockBtn = card?.querySelector('button[onclick*="toggleLock"]');

                    if (card) {
                        // Update lock button if found
                        if (lockBtn) {
                            lockBtn.textContent = locked ? 'üîí' : 'üîì';
                            lockBtn.title = locked ? 'Unlock meal' : 'Lock meal';
                        }

                        // Update border color based on lock state
                        if (locked) {
                            card.style.borderColor = '#1976d2';  // Blue for locked
                            card.style.backgroundColor = '#e3f2fd';  // Light blue background
                        } else {
                            card.style.borderColor = '#4169E1';  // Default blue for meals
                            card.style.backgroundColor = '#f0f8f0';  // Default green background
                        }

                        card.classList.toggle('locked', locked);
                    }
                },

                // Sync to Redis (placeholder for Phase 4)
                syncToRedis: async function(index, locked) {
                    const phone = FarmDashboard.Utils.getPhoneNumber();
                    if (!phone) throw new Error('No phone number available');

                    const response = await fetch('/api/meal-lock', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ phone, index, locked })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to sync lock to server');
                    }
                },

                // Sync from Redis
                syncFromRedis: async function() {
                    try {
                        const phone = FarmDashboard.Utils.getPhoneNumber();
                        const response = await fetch(`/api/meal-locks?phone=${phone}`);

                        if (response.ok) {
                            const data = await response.json();
                            this.state.locked = data.locked_status || [false, false, false, false, false];
                            this.state.version = data.version || 0;
                            this.updateAllLockUI();
                        }
                    } catch (error) {
                        console.error('‚ùå Failed to sync from Redis:', error);
                    }
                },

                // Update all lock UI elements
                updateAllLockUI: function() {
                    this.state.locked.forEach((locked, index) => {
                        this.updateLockUI(index, locked);
                    });
                },

                // Setup sync strategy
                setupSync: function() {
                    // On tab change to Meals
                    document.addEventListener('tabChanged', (e) => {
                        if (e.detail?.tab === 'plan') {
                            this.syncFromRedis();
                        }
                    });

                    // On window focus (for multi-tab sync)
                    window.addEventListener('focus', () => {
                        if (this.hasLocks()) {
                            this.syncFromRedis();
                        }
                    });

                    // Periodic sync if locks exist
                    this.state.syncTimer = setInterval(() => {
                        if (this.hasLocks()) {
                            this.checkVersion(); // Lightweight check
                        }
                    }, 30000);
                },

                // Check if any meals are locked
                hasLocks: function() {
                    return this.state.locked.some(locked => locked);
                },

                // Mark Cart tab as needing sync
                markCartTabStale: function() {
                    // Immediately refresh Cart tab meal display with lock status
                    FarmDashboard.Cart.refreshMealDisplay();
                },

                // Clear all locks
                clearAll: async function() {
                    if (!this.hasLocks()) return;

                    try {
                        const phone = FarmDashboard.Utils.getPhoneNumber();
                        await fetch('/api/meal-locks', {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ phone })
                        });

                        this.state.locked = [false, false, false, false, false];
                        this.updateAllLockUI();
                        FarmDashboard.Utils.showToast('All locks cleared', 'success');

                    } catch (error) {
                        console.error('‚ùå Failed to clear locks:', error);
                        FarmDashboard.Utils.showToast('Failed to clear locks', 'error');
                    }
                }
            }
        };

        // Legacy globals for backward compatibility (will be phased out)
        let currentState = 'start'; // start, loading, complete
        let mealPlanData = null;
        let refreshesLeft = 3;  // Track refresh count

        // Debouncing variables to prevent multiple API calls
        let mealGenerationInProgress = false;

        // Global timer variables to prevent duplicate progress timers
        let statusInterval = null;
        let analysisTimeout = null;
        let isAnalyzing = false;
        let currentAbortController = null; // Add AbortController for canceling requests
        let lastMealGenerationTime = 0;
        const MEAL_DEBOUNCE_TIMEOUT = 500; // 500ms debounce
        let mealGenerationTimeoutId = null;

        // Clear stale cache data to prevent cross-user contamination
        const currentUser = localStorage.getItem('ftpEmail');
        const lastUser = localStorage.getItem('lastLoggedInUser');
        
        if (currentUser && currentUser !== lastUser) {
            // Different user logged in - clear all cached data
            console.log('Different user detected, clearing cache...');
            localStorage.removeItem('cartAnalysisData');
            localStorage.removeItem('cartAnalysisState');
            localStorage.removeItem('cachedMealSuggestions');
            localStorage.removeItem('cachedMealSuggestionsTimestamp');
            localStorage.removeItem('refreshesLeft');
            localStorage.setItem('lastLoggedInUser', currentUser);
        }

        // Check if we have saved credentials
        const userEmail = localStorage.getItem('ftpEmail');
        if (userEmail) {
            document.querySelector('.subtitle').textContent = userEmail;
        }
        
        // Function to load saved cart data from the server (PRIORITY: Redis > Database > localStorage)
        async function loadSavedCartData() {
            console.log('üîç Loading cart data with priority: Redis > Database > localStorage');

            // Show loading immediately to prevent blank screen
            const loadingSection = document.getElementById('loadingSection');
            const startSection = document.getElementById('startSection');

            if (loadingSection) {
                loadingSection.classList.add('active');
                console.log('üîÑ Showing loading state immediately');
            }
            if (startSection) {
                startSection.classList.remove('active');
            }

            // PRIORITY 1: Always check server first (Redis > Database)
            try {
                console.log('üì° Fetching fresh data from server (Redis/Database)...');
                const response = await fetch('/api/get-saved-cart?force_refresh=false');
                if (response.ok) {
                    const data = await response.json();
                    if (data && data.cart_data && Object.keys(data.cart_data).length > 0) {
                        const cacheSource = data.from_cache ? `${data.cache_type} cache` : 'database';
                        console.log(`‚úÖ Loaded fresh cart from server: ${cacheSource}`);

                        // Clear any stale localStorage data when we get fresh server data
                        if (data.from_cache && data.cache_type && data.cache_type.includes('redis')) {
                            console.log('üóëÔ∏è Clearing stale localStorage - using fresh Redis data');
                            localStorage.removeItem('cartAnalysisData');
                            localStorage.removeItem('cartAnalysisState');
                        }

                        // Show delivery date if available from server
                        if (data.delivery_date) {
                            console.log(`üìÖ Delivery date from server: ${data.delivery_date}`);
                        }

                        currentState = 'complete';
                        console.log('üè† Page load - About to call showCartAnalysis() with cached data');

                        // Hide loading, show cart analysis
                        if (loadingSection) loadingSection.classList.remove('active');

                        FarmDashboard.Cart.showAnalysis(data.cart_data, data.swaps || [], data.addons || [], false, data.meals || null);
                        return true;
                    }
                }
            } catch (error) {
                console.error('‚ö†Ô∏è Error loading from server:', error);
            }

            // No cart found - show start screen
            console.log('‚ùå No valid cart data found in Redis/Database - showing start screen');

            if (loadingSection) loadingSection.classList.remove('active');
            if (startSection) {
                startSection.classList.add('active');
                console.log('üéØ Showing start screen - ready for cart analysis');
            }

            return false;
        }
        
        // NOTE: These are now handled by FarmDashboard.init()
        // Load saved cart data on page load - MOVED TO FarmDashboard.Cart.init()
        // loadSavedCartData();

        // Restore cart lock time on page load - MOVED TO FarmDashboard.Cart.init()
        // restoreCartLockTime();

        async function startAnalysis(forceRefresh = false) {
            // Prevent overlapping analysis calls
            if (isAnalyzing) {
                console.log('‚ö†Ô∏è Analysis already in progress, ignoring duplicate call');
                return;
            }

            // Clear any existing timers to prevent duplicates
            clearAnalysisTimers();

            // Set analyzing flag and create new AbortController
            isAnalyzing = true;
            currentAbortController = new AbortController();

            // Clear ALL previous analysis data to prevent stale cache issues
            localStorage.removeItem('cartAnalysisData');
            localStorage.removeItem('cartAnalysisState');
            localStorage.removeItem('cachedMealSuggestions');
            localStorage.removeItem('cachedMealSuggestionsTimestamp');

            // Switch to loading state
            currentState = 'loading';

            // Clean up any conflicting inline styles first
            ['startSection', 'loadingSection', 'cartAnalysisSection'].forEach(id => {
                const section = document.getElementById(id);
                if (section) section.style.display = ''; // Clear inline styles
            });

            // Set the state with both classList AND inline styles for reliability
            document.getElementById('startSection').classList.remove('active');
            document.getElementById('cartAnalysisSection').classList.remove('active');

            const loadingSection = document.getElementById('loadingSection');
            loadingSection.classList.add('active');
            loadingSection.style.display = 'block'; // Force visible to override any conflicts

            document.getElementById('headerSubtitle').textContent = 'Analyzing...';

            // Add diagnostic logging to track state
            console.log('üîÑ startAnalysis() - State transition to loading:', {
                start: document.getElementById('startSection').classList.contains('active'),
                loading: document.getElementById('loadingSection').classList.contains('active'),
                cart: document.getElementById('cartAnalysisSection').classList.contains('active'),
                currentState: currentState,
                forceRefresh: forceRefresh
            });

            // Update loading status messages with progress bar and timer
            const statuses = [
                { text: 'üîê Connecting to Farm to People...', progress: 10 },
                { text: 'üîç Accessing your current cart...', progress: 25 },
                { text: 'üì¶ Scanning cart items and customizable boxes...', progress: 45 },
                { text: 'üßÆ Calculating ingredients and portions...', progress: 60 },
                { text: 'ü§ñ Generating personalized meal suggestions with GPT-5...', progress: 80 },
                { text: '‚ú® Finalizing your meal plan and saving to cache...', progress: 95 }
            ];

            let statusIndex = 0;
            const startTime = Date.now();

            // Add progress bar to loading status
            function updateLoadingStatus() {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const status = statuses[Math.min(statusIndex, statuses.length - 1)];

                // Create smooth progress updates without affecting spinner
                const loadingEl = document.getElementById('loadingStatus');

                // Use requestAnimationFrame for smoother updates
                requestAnimationFrame(() => {
                    loadingEl.innerHTML = `
                        <div style="margin-bottom: 12px;">${status.text}</div>
                        <div style="background: #f0f0f0; border-radius: 8px; height: 6px; margin-bottom: 8px; overflow: hidden;">
                            <div style="background: #4169E1; height: 100%; width: ${status.progress}%; transition: width 0.8s ease;"></div>
                        </div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 8px;">Elapsed: ${elapsed}s</div>
                        <button onclick="cancelAnalysis()" style="padding: 6px 12px; background: #ff6b6b; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            Cancel
                        </button>
                    `;
                });
            }

            updateLoadingStatus();
            statusInterval = setInterval(() => {
                if (statusIndex < statuses.length - 1) {
                    statusIndex++;
                }
                updateLoadingStatus();
            }, 8000); // Slower updates for longer processes

            // Cancel button is now included in updateLoadingStatus() function above

            // Add timeout for scraping (PWA recovery mechanism)
            analysisTimeout = setTimeout(() => {
                clearAnalysisTimers();
                if (currentState === 'loading') {
                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                    // Show error with retry and cancel options
                    document.getElementById('loadingStatus').innerHTML = `
                        <div style="color: #ff6b6b; margin-bottom: 12px;">‚ö†Ô∏è Analysis taking longer than expected (${elapsed}s)</div>
                        <div style="font-size: 14px; color: #666; margin-bottom: 12px;">
                            This usually means the Farm to People website is slow or experiencing issues.
                        </div>
                        <button onclick="retryAnalysis()" style="padding: 8px 16px; background: #4169E1; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px;">
                            Try Again
                        </button>
                        <button onclick="cancelAnalysis()" style="padding: 8px 16px; background: #ff6b6b; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px;">
                            Cancel
                        </button>
                        <button onclick="goBackToStart()" style="padding: 8px 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            Go Back
                        </button>
                    `;
                }
            }, 60000); // 60 second timeout

            try {
                // Get user phone (from localStorage or prompt)
                let userPhone = localStorage.getItem('userPhone');
                if (!userPhone) {
                    userPhone = prompt('Enter your phone number to analyze your cart:');
                    if (userPhone) {
                        // Ensure we store the full phone number
                        userPhone = userPhone.replace(/\D/g, ''); // Remove non-digits
                        localStorage.setItem('userPhone', userPhone);
                    }
                }
                
                // Fix common phone issues
                if (userPhone) {
                    userPhone = userPhone.replace(/\D/g, ''); // Remove all non-digits
                    // If it's 9 digits and starts with 425 (Seattle area), add the missing digit
                    if (userPhone === '425495323') {
                        userPhone = '4254955323'; // Fix known truncated number
                    }
                }
                
                // Start the actual analysis
                // Pass phone number to use stored credentials from database
                const response = await fetch('/api/analyze-cart', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    signal: currentAbortController.signal, // Add abort signal
                    body: JSON.stringify({
                        phone: userPhone,
                        use_mock: false,  // Set to true to use mock data for testing
                        force_refresh: forceRefresh  // Pass force refresh parameter
                    })
                });

                const data = await response.json();
                clearAnalysisTimers();
                const apiTime = Date.now() - apiCallStart;
                console.log(`‚è±Ô∏è [UI T+${Date.now() - uiStartTime}ms] API response received (took ${apiTime}ms)`);

                if (data.success) {
                    console.log('‚úÖ Cart analysis API response received:', {
                        fresh_scrape: data.fresh_scrape,
                        has_cart_data: !!data.cart_data,
                        has_meals: !!data.meals,
                        currentState: currentState,
                        isAnalyzing: isAnalyzing
                    });

                    // CRITICAL: Clear localStorage if fresh data was scraped
                    if (data.fresh_scrape) {
                        console.log('üßπ Fresh scrape detected - clearing localStorage cache');
                        localStorage.removeItem('cartData');
                        localStorage.removeItem('cartTimestamp');
                        localStorage.removeItem('lastCartAnalysis');
                    }

                    isAnalyzing = false; // Reset analyzing flag on success
                    console.log(`‚è±Ô∏è [UI T+${Date.now() - uiStartTime}ms] Rendering cart analysis UI`);
                    console.log('üéØ About to call showCartAnalysis()');
                    FarmDashboard.Cart.showAnalysis(data.cart_data, data.swaps, data.addons, data.fresh_scrape, data.meals);
                    console.log(`‚è±Ô∏è [UI T+${Date.now() - uiStartTime}ms] UI update complete`);
                } else {
                    // Show error message instead of mock data
                    isAnalyzing = false; // Reset analyzing flag on error
                    showError(data.error || 'Failed to analyze cart', data.debug_info);
                }
            } catch (error) {
                clearAnalysisTimers();
                isAnalyzing = false; // Reset analyzing flag on network error
                const totalTime = Date.now() - uiStartTime;
                console.log(`‚è±Ô∏è [UI T+${totalTime}ms] Error occurred during analysis`);

                // Handle abort error specifically (user canceled)
                if (error.name === 'AbortError') {
                    console.log('‚úÖ Analysis canceled by user');
                    return; // cancelAnalysis() already handles UI reset
                }

                // Show error message for other errors
                showError('Network error: ' + error.message);
            }
        }

        // Retry function for stuck scraping (PWA recovery)
        function retryAnalysis() {
            location.reload(); // Safe reload for retry
        }

        // Helper function to clear all analysis timers
        function clearAnalysisTimers() {
            if (statusInterval) {
                clearInterval(statusInterval);
                statusInterval = null;
            }
            if (analysisTimeout) {
                clearTimeout(analysisTimeout);
                analysisTimeout = null;
            }
        }

        // Cancel analysis and go back to start
        function cancelAnalysis() {
            console.log('üö´ cancelAnalysis() called');

            // Abort the current request if it exists
            if (currentAbortController) {
                console.log('üì° Aborting server request...');
                currentAbortController.abort();
                currentAbortController = null;
            }

            // Clear all timers to prevent duplicates
            clearAnalysisTimers();

            // Reset analyzing flag
            isAnalyzing = false;

            // Clean up any conflicting inline styles first (same as startAnalysis)
            ['startSection', 'loadingSection', 'cartAnalysisSection'].forEach(id => {
                const section = document.getElementById(id);
                if (section) section.style.display = ''; // Clear inline styles
            });

            // Reset to start state with clean transitions
            currentState = 'start';
            document.getElementById('loadingSection').classList.remove('active');
            document.getElementById('cartAnalysisSection').classList.remove('active');
            document.getElementById('startSection').classList.add('active');
            document.getElementById('headerSubtitle').textContent = 'Ready to analyze';

            console.log('‚úÖ Analysis canceled and UI reset to start');
        }

        // Go back to start from error state
        function goBackToStart() {
            cancelAnalysis();
        }

        function showScrapedTimestamp(cartData) {
            // Show when this cart was scraped
            const timestamp = cartData.scraped_timestamp;
            if (timestamp) {
                const date = new Date(timestamp);

                // Debug logging to understand timezone issues
                console.log('üïê Timestamp debug:', {
                    raw: timestamp,
                    date: date,
                    userTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    dateString: date.toString(),
                    isoString: date.toISOString()
                });

                // Force local timezone interpretation
                const formatted = date.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true,
                    timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
                });
                
                // Add timestamp display near delivery date
                const deliveryElem = document.getElementById('deliveryDate');
                if (deliveryElem) {
                    // First, remove any existing timestamp divs to prevent duplicates
                    const textElem = document.getElementById('deliveryDateText');
                    if (textElem && textElem.parentNode) {
                        const existingTimestamps = textElem.parentNode.querySelectorAll('div[style*="font-size: 11px"]');
                        existingTimestamps.forEach(div => {
                            if (div.innerHTML.includes('Cart updated:')) {
                                div.remove();
                            }
                        });

                        // Now create and add the new timestamp
                        const timestampDiv = document.createElement('div');
                        timestampDiv.style.fontSize = '11px';
                        timestampDiv.style.color = '#888';
                        timestampDiv.style.marginTop = '2px';
                        timestampDiv.innerHTML = `<i>Cart updated: ${formatted}</i>`;
                        textElem.parentNode.appendChild(timestampDiv);
                    }
                }
            }
        }
        
        function showError(message, debugInfo) {
            currentState = 'error';
            document.getElementById('loadingSection').classList.remove('active');
            document.getElementById('cartAnalysisSection').classList.add('active');
            document.getElementById('headerSubtitle').textContent = 'Error analyzing cart';
            
            // Show error in the cart analysis section
            document.getElementById('cartAnalysisSection').innerHTML = `
                <div style="background: #fee; border: 2px solid #fcc; border-radius: 12px; padding: 20px; margin: 20px;">
                    <h3 style="color: #d00; margin-bottom: 10px;">‚ö†Ô∏è Cart Analysis Error</h3>
                    <p style="color: #800; margin-bottom: 10px;">${message}</p>
                    ${debugInfo ? `<details style="margin-top: 10px;">
                        <summary style="cursor: pointer; color: #666;">Debug Info (click to expand)</summary>
                        <pre style="background: #f5f5f5; padding: 10px; margin-top: 10px; font-size: 12px; overflow-x: auto;">${typeof debugInfo === 'string' ? debugInfo : JSON.stringify(debugInfo, null, 2)}</pre>
                    </details>` : ''}
                    <button onclick="FarmDashboard.Cart.startAnalysis()" style="background: #28a745; color: white; border: none; padding: 12px 24px; border-radius: 8px; margin-top: 15px; cursor: pointer;">Try Again</button>
                </div>
            `;
        }
        
        // Mock data function removed - no longer needed since real cart analysis is working

        // Helper function to clean duplicate producer names
        function cleanProducerName(producer) {
            if (!producer) return '';
            // Handle duplicated names like "Lagoner FarmsLagoner Farms"
            // Check if the name is duplicated by seeing if first half equals second half
            const halfLength = Math.floor(producer.length / 2);
            const firstHalf = producer.substring(0, halfLength);
            const secondHalf = producer.substring(halfLength);
            
            if (firstHalf === secondHalf) {
                return firstHalf;
            }
            
            // Also handle cases with slight variations
            // Try to detect if a farm name appears twice
            const commonFarmWords = ['Farm', 'Farms', 'Acres', 'Growers', 'Harvest', 'Cooperative'];
            for (const word of commonFarmWords) {
                const pattern = new RegExp(`(.+${word})\\1`, 'i');
                const match = producer.match(pattern);
                if (match) {
                    return match[1];
                }
            }
            
            return producer;
        }
        
        // Helper function to determine item category
        function getItemCategory(itemName) {
            const name = itemName.toLowerCase();
            
            // Protein items
            if (name.includes('chicken') || name.includes('beef') || name.includes('turkey') || 
                name.includes('pork') || name.includes('sausage') || name.includes('fish') || 
                name.includes('salmon') || name.includes('bass') || name.includes('egg') ||
                name.includes('kielbasa') || name.includes('steelhead') || name.includes('filet') ||
                name.includes('cod') || name.includes('tuna') || name.includes('shrimp')) {
                return 'protein';
            }
            
            // Dairy items
            if (name.includes('cheese') || name.includes('milk') || name.includes('yogurt') || 
                name.includes('butter') || name.includes('mozzarella') || name.includes('cheddar') ||
                name.includes('feta')) {
                return 'dairy';
            }
            
            // Fruit items - be very specific about what is actually a fruit
            // Only include items that are typically snackable fruits
            if (name.includes('apple') || name.includes('banana') || name.includes('peach') || 
                name.includes('plum') || name.includes('nectarine') || name.includes('berry') ||
                name.includes('melon') || name.includes('pear') || name.includes('grape') ||
                name.includes('grapefruit') || name.includes('mango')) {
                return 'fruit';
            }
            
            // Check for oranges specifically (but not orange-colored vegetables)
            if (name.includes('orange') && !name.includes('carrot') && !name.includes('pepper') && 
                !name.includes('bell') && !name.includes('squash')) {
                return 'fruit';
            }
            
            // Default to produce (vegetables, herbs, etc)
            // This includes tomatoes, peppers, lettuce, kale, zucchini, carrots, etc.
            return 'produce';
        }
        
        // Helper function to show delivery date in header
        function showDeliveryDate(cartData) {
            const deliveryInfo = cartData?.delivery_info;
            if (deliveryInfo && deliveryInfo.delivery_text) {
                // Parse formats: "Thu, Sep 18, 4:00PM - 8:00PM" or "Shopping for: Thu, Sep 18, 4:00PM - 8:00PM"
                const text = deliveryInfo.delivery_text;
                console.log('üìÖ Parsing delivery date:', text);

                // Try multiple patterns to handle different formats
                let match = text.match(/(?:Shopping for: )?(\w+), (\w+ \d+), (\d{1,2}:\d{2}[AP]M)/);

                if (match) {
                    const [_, day, date, startTime] = match;
                    // Format: "Thu, Sep 18 ‚Ä¢ 4:00PM"
                    const displayText = `${day}, ${date} ‚Ä¢ ${startTime}`;

                    console.log('‚úÖ Formatted delivery date:', displayText);

                    document.getElementById('deliveryDateText').textContent = displayText;
                    document.getElementById('deliveryDate').style.display = 'block';

                    // Calculate and show cart cutoff time (pass full date for proper calculation)
                    showCartCutoffTime(`${day}, ${date}`);
                } else {
                    console.log('‚ö†Ô∏è Could not parse delivery date, using fallback');
                    // Fallback - show raw text (cleaned)
                    const cleanText = text.replace('Shopping for: ', '').replace(/ - \d{1,2}:\d{2}[AP]M/, '');
                    document.getElementById('deliveryDateText').textContent = cleanText;
                    document.getElementById('deliveryDate').style.display = 'block';
                }
            }
        }
        
        function showCartCutoffTime(deliveryDateStr) {
            console.log('üïí Calculating cart cutoff time for delivery:', deliveryDateStr);

            try {
                // Parse "Thu, Sep 18" format
                const dateMatch = deliveryDateStr.match(/(\w+), (\w+) (\d+)/);
                if (!dateMatch) {
                    console.log('‚ö†Ô∏è Could not parse delivery date format');
                    return;
                }

                const [_, dayName, month, dayNum] = dateMatch;
                const year = new Date().getFullYear();

                // Create actual date object for delivery
                const deliveryDate = new Date(`${month} ${dayNum}, ${year}`);
                console.log('üìÖ Delivery date parsed:', deliveryDate.toDateString());

                // Calculate cutoff date (day before delivery)
                const cutoffDate = new Date(deliveryDate);
                cutoffDate.setDate(cutoffDate.getDate() - 1);

                // Format cutoff day name
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const cutoffDay = days[cutoffDate.getDay()];
                const cutoffText = `${cutoffDay} ‚Ä¢ 11:59AM`;

                console.log('‚úÖ Calculated cutoff:', cutoffText, 'for delivery on:', deliveryDate.toDateString());

                // Store in localStorage for persistence across page refreshes
                localStorage.setItem('cartLockTime', cutoffText);
                localStorage.setItem('cartLockExpiry', Date.now() + 3600000); // 1 hour expiry

                // Display the cart lock time
                displayCartLockTime(cutoffText);
            } catch (error) {
                console.error('‚ùå Error calculating cart cutoff time:', error);
            }
        }

        // Helper function to display cart lock time (separate for reuse)
        function displayCartLockTime(cutoffText) {
            // Remove any existing cutoff warning first
            const existingCutoff = document.getElementById('cartCutoffWarning');
            if (existingCutoff) {
                existingCutoff.remove();
            }

            // Find header to attach to
            const headerSubtitle = document.getElementById('headerSubtitle');
            if (!headerSubtitle) return;

            // Create and add cutoff time warning
            const cutoffDiv = document.createElement('div');
            cutoffDiv.id = 'cartCutoffWarning';
            cutoffDiv.style.cssText = 'color: #FF6B35; font-size: 12px; margin-top: 4px; font-weight: 500;';
            cutoffDiv.innerHTML = `‚è∞ Cart locks: ${cutoffText}`;

            // Insert after the subtitle
            const headerElement = headerSubtitle.parentElement;
            if (headerElement) {
                headerElement.appendChild(cutoffDiv);
            }
        }

        // On page load, restore cart lock if valid and available
        function restoreCartLockTime() {
            const savedLock = localStorage.getItem('cartLockTime');
            const lockExpiry = localStorage.getItem('cartLockExpiry');

            if (savedLock && lockExpiry && Date.now() < parseInt(lockExpiry)) {
                console.log('üîÑ Restoring cart lock time from localStorage:', savedLock);
                displayCartLockTime(savedLock);
            } else if (savedLock) {
                console.log('üóëÔ∏è Cart lock time expired, clearing localStorage');
                localStorage.removeItem('cartLockTime');
                localStorage.removeItem('cartLockExpiry');
            }
        }
        
        // Helper function to get category colors (minimal style like the reference image)
        function getCategoryColors(category) {
            const colors = {
                'protein': { bg: '#FFF0F0', text: '#D32F2F', border: '#FFCDD2' },
                'produce': { bg: '#F1F8F4', text: '#2E7D32', border: '#C8E6C9' },
                'dairy': { bg: '#E3F2FD', text: '#1976D2', border: '#BBDEFB' },
                'fruit': { bg: '#FFF8E1', text: '#F57C00', border: '#FFE082' },  // Changed to orange like pantry
                'pantry': { bg: '#FFF8E1', text: '#F57C00', border: '#FFE082' }
            };
            return colors[category] || colors['produce'];
        }
        
        function showCartAnalysis(cartData, swaps = [], addons = [], freshScrape = false, cachedMeals = null) {
            currentState = 'complete';

            // Set global mealPlanData so meal calendar can access cart data
            mealPlanData = { cart_data: cartData };

            // Cart analysis complete (no localStorage caching - using Redis only)
            console.log('üíæ Cart analysis complete - data served from Redis');

            // CRITICAL FIX: Hide all other sections first (both class and inline styles)
            document.getElementById('startSection').classList.remove('active');

            const loadingSection = document.getElementById('loadingSection');
            loadingSection.classList.remove('active');
            loadingSection.style.display = 'none'; // Explicitly hide to prevent conflicts

            // Then show the cart analysis section
            document.getElementById('cartAnalysisSection').classList.add('active');
            document.getElementById('headerSubtitle').textContent = 'Cart analysis complete';

            // Add diagnostic logging to track state
            console.log('üîç Active sections after showCartAnalysis:', {
                start: document.getElementById('startSection').classList.contains('active'),
                loading: document.getElementById('loadingSection').classList.contains('active'),
                cart: document.getElementById('cartAnalysisSection').classList.contains('active')
            });

            // Show delivery date and timestamp if available
            showDeliveryDate(cartData);
            showScrapedTimestamp(cartData);

            // Handle meal suggestions based on context
            if (freshScrape) {
                // Fresh scrape - meals should already be generated and included in the response
                console.log('üîÑ Fresh cart data - meals should be included from server');
                if (cachedMeals && cachedMeals.length > 0) {
                    displayMealSuggestions(cachedMeals);
                } else {
                    console.log('‚ö†Ô∏è Fresh scrape but no meals in response - user can click "New Suggestions"');
                    showEmptyMealState();
                }
            } else if (cachedMeals && cachedMeals.length > 0) {
                // Page refresh - use cached meals
                console.log('üíæ Using cached meal suggestions from Redis');
                displayMealSuggestions(cachedMeals);
            } else {
                // No cached meals available - show empty state
                console.log('üì¶ No meal suggestions yet - click "New Suggestions" to generate');
                showEmptyMealState();
            }

            // Sync meals from Cart tab to Meals tab
            setTimeout(() => {
                FarmDashboard.Meals.syncFromCart();
            }, 500);
            
            // Calculate and display category counts
            const categoryCounts = { protein: 0, produce: 0, fruit: 0 };
            
            // Count from individual items
            if (cartData.individual_items) {
                cartData.individual_items.forEach(item => {
                    const category = getItemCategory(item.name);
                    if (category === 'protein' || category === 'produce' || category === 'fruit') {
                        categoryCounts[category] += item.quantity || 1;
                    }
                });
            }
            
            // Count from customizable boxes
            if (cartData.customizable_boxes) {
                cartData.customizable_boxes.forEach(box => {
                    if (box.selected_items) {
                        box.selected_items.forEach(item => {
                            const category = getItemCategory(item.name);
                            if (category === 'protein' || category === 'produce' || category === 'fruit') {
                                categoryCounts[category] += item.quantity || 1;
                            }
                        });
                    }
                });
            }
            
            // Count from non_customizable_boxes (but some might actually be customizable!)
            if (cartData.non_customizable_boxes) {
                cartData.non_customizable_boxes.forEach(box => {
                    if (box.selected_items) {
                        box.selected_items.forEach(item => {
                            const category = getItemCategory(item.name);
                            if (category === 'protein' || category === 'produce' || category === 'fruit') {
                                categoryCounts[category] += item.quantity || 1;
                            }
                        });
                    }
                });
            }
            
            // Display summary with category counts - all in one row
            const summaryItems = [];
            
            if (categoryCounts.protein > 0) {
                summaryItems.push(`
                    <span style="font-size: 18px; color: #333; font-weight: 500;">${categoryCounts.protein}√ó protein</span>
                `);
            }
            
            // Remove produce from summary - user only wants protein and fruit counts
            
            if (categoryCounts.fruit > 0) {
                summaryItems.push(`
                    <span style="font-size: 18px; color: #333; font-weight: 500;">${categoryCounts.fruit}√ó fruit</span>
                `);
            }
            
            
            // Remove add-ons from summary for cleaner look
            
            document.getElementById('cartSummary').innerHTML = summaryItems.join('');

            // Show individual items with category tags
            if (cartData.individual_items && cartData.individual_items.length > 0) {
                // Update count
                document.getElementById('individualItemsCount').textContent = `(${cartData.individual_items.length} items)`;
                
                const individualHTML = cartData.individual_items.map(item => {
                    // Get category and colors
                    const category = getItemCategory(item.name);
                    const colors = getCategoryColors(category);
                    
                    // Format quantity properly
                    let quantityText = '';
                    if (item.unit.startsWith('1 ')) {
                        // Unit already contains "1 dozen", "1 piece", etc.
                        // Replace the "1" with actual quantity if different
                        if (item.quantity === 1) {
                            quantityText = item.unit;
                        } else {
                            // Replace "1 piece" with "5 pieces", "1 dozen" stays as is for quantity 1
                            const unitPart = item.unit.substring(2); // Remove "1 " prefix
                            // Pluralize if needed
                            if (item.quantity > 1 && unitPart === 'piece') {
                                quantityText = `${item.quantity} pieces`;
                            } else if (item.quantity > 1 && unitPart === 'bunch') {
                                quantityText = `${item.quantity} bunches`;
                            } else if (item.quantity > 1 && unitPart === 'head') {
                                quantityText = `${item.quantity} heads`;
                            } else {
                                quantityText = `${item.quantity} ${unitPart}`;
                            }
                        }
                    } else {
                        // Unit doesn't start with "1 ", use as is
                        quantityText = item.quantity > 1 ? `${item.quantity} √ó ${item.unit}` : item.unit;
                    }
                    
                    return `
                        <div class="cart-item" style="display: flex; align-items: center; padding: 12px; border-bottom: 1px solid #eee;">
                            <div class="item-details" style="flex: 1;">
                                <div class="item-name" style="font-size: 14px; font-weight: 600; color: #4169E1; margin-bottom: 2px;">${item.name}</div>
                                <div class="item-meta" style="color: #666; font-size: 12px;">${quantityText}${item.producer ? ` ‚Ä¢ ${cleanProducerName(item.producer)}` : ''}</div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div class="item-price" style="color: #2e7d32; font-weight: 600; font-size: 14px; min-width: 55px; text-align: right;">${item.price || ''}</div>
                                <span class="category-tag" style="
                                    background: rgba(255, 255, 255, 0.7);
                                    color: ${colors.text};
                                    padding: 3px 9px;
                                    border-radius: 10px;
                                    font-size: 12px;
                                    font-weight: 500;
                                    text-align: center;
                                    border: 1px solid rgba(0, 0, 0, 0.1);
                                    display: inline-block;
                                    opacity: 0.9;
                                ">${category}</span>
                            </div>
                        </div>
                    `;
                }).join('');
                document.getElementById('individualItems').innerHTML = individualHTML;
            } else {
                document.getElementById('individualItemsSection').style.display = 'none';
            }

            // Separate boxes based on customizable flag (not which array they're in)
            const allBoxes = [...(cartData.customizable_boxes || []), ...(cartData.non_customizable_boxes || [])];

            console.log('üîç Debug cart box data:', {
                customizable_boxes: cartData.customizable_boxes,
                non_customizable_boxes: cartData.non_customizable_boxes,
                allBoxes: allBoxes
            });

            const actuallyCustomizable = allBoxes.filter(box => box.customizable === true || box.customizable === undefined && box.alternatives_count > 0);
            const actuallyNonCustomizable = allBoxes.filter(box => box.customizable === false);

            console.log('üîç Box filtering results:', {
                actuallyCustomizable: actuallyCustomizable,
                actuallyNonCustomizable: actuallyNonCustomizable
            });
            
            // Show customizable boxes with category tags
            if (actuallyCustomizable.length > 0) {
                // Update count
                let totalItems = 0;
                actuallyCustomizable.forEach(box => {
                    totalItems += (box.selected_items ? box.selected_items.length : 0);
                });
                document.getElementById('customizableBoxesCount').textContent = `(${totalItems} items)`;
                
                const customizableHTML = actuallyCustomizable.map(box => `
                    <div style="margin-bottom: 20px;">
                        <div class="box-header">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div class="box-name">${box.box_name}</div>
                                ${box.price ? `<span style="color: #2e7d32; font-weight: normal; font-size: 16px;">${box.price}</span>` : ''}
                            </div>
                            <div class="box-status">${box.alternatives_count} available alternatives</div>
                        </div>
                        <div class="item-grid">
                            ${box.selected_items.map(item => {
                                const category = getItemCategory(item.name);
                                const colors = getCategoryColors(category);
                                return `
                                    <div class="cart-item" style="display: flex; align-items: center; padding: 12px; border-bottom: 1px solid #eee;">
                                        <div class="item-details" style="flex: 1;">
                                            <div class="item-name">${item.name}</div>
                                            <div class="item-meta" style="color: #666; font-size: 14px;">${item.unit}${item.producer ? ` ‚Ä¢ ${cleanProducerName(item.producer)}` : ''}</div>
                                        </div>
                                        <span class="category-tag" style="
                                            background: rgba(255, 255, 255, 0.7);
                                            color: ${colors.text};
                                            padding: 3px 9px;
                                            border-radius: 10px;
                                            font-size: 12px;
                                            font-weight: 500;
                                            text-align: center;
                                            border: 1px solid rgba(0, 0, 0, 0.1);
                                            display: inline-block;
                                            opacity: 0.9;
                                        ">${category}</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `).join('');
                document.getElementById('customizableBoxes').innerHTML = customizableHTML;
            } else {
                document.getElementById('customizableBoxesSection').style.display = 'none';
            }

            // Show non-customizable boxes with category tags
            if (actuallyNonCustomizable.length > 0) {
                // Update count
                let totalItems = 0;
                actuallyNonCustomizable.forEach(box => {
                    totalItems += (box.selected_items ? box.selected_items.length : 0);
                });
                document.getElementById('fixedBoxesCount').textContent = `(${totalItems} items)`;
                
                const nonCustomizableHTML = actuallyNonCustomizable.map(box => `
                    <div style="margin-bottom: 20px;">
                        <div class="box-header">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div class="box-name">${box.box_name}</div>
                                ${box.price ? `<span style="color: #2e7d32; font-weight: normal; font-size: 16px;">${box.price}</span>` : ''}
                            </div>
                            <div class="box-status">Fixed selection</div>
                        </div>
                        <div class="item-grid">
                            ${box.selected_items.map(item => {
                                const category = getItemCategory(item.name);
                                const colors = getCategoryColors(category);
                                return `
                                    <div class="cart-item" style="display: flex; align-items: center; padding: 12px; border-bottom: 1px solid #eee;">
                                        <div class="item-details" style="flex: 1;">
                                            <div class="item-name">${item.name}</div>
                                            <div class="item-meta" style="color: #666; font-size: 14px;">${item.unit}</div>
                                        </div>
                                        <span class="category-tag" style="
                                            background: rgba(255, 255, 255, 0.7);
                                            color: ${colors.text};
                                            padding: 3px 9px;
                                            border-radius: 10px;
                                            font-size: 12px;
                                            font-weight: 500;
                                            text-align: center;
                                            border: 1px solid rgba(0, 0, 0, 0.1);
                                            display: inline-block;
                                            opacity: 0.9;
                                        ">${category}</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `).join('');
                document.getElementById('nonCustomizableBoxes').innerHTML = nonCustomizableHTML;
            } else {
                document.getElementById('nonCustomizableBoxesSection').style.display = 'none';
            }

            // Show AI-generated swaps (2025-08-29: Using GPT-5 generated swaps)
            if (swaps && swaps.length > 0) {
                const swapsHTML = swaps.map(swap => `
                    <div class="swap-suggestion">
                        <div class="swap-text">Swap ${swap.from} ‚Üí ${swap.to}</div>
                        <div class="swap-reason" style="font-size: 12px; color: #666; margin-top: 4px;">${swap.reason}</div>
                    </div>
                `).join('');
                document.getElementById('suggestedSwaps').innerHTML = swapsHTML;
            } else {
                document.getElementById('suggestedSwaps').innerHTML = '<div style="color: #666; padding: 10px;">No swaps needed - your selections look great!</div>';
            }

            // Show AI-generated fresh add-ons (2025-08-29: Fresh ingredients only, no pantry staples)
            if (addons && addons.length > 0) {
                const addonsHTML = addons.map(addon => {
                    // Determine category and color using the same helper function
                    const category = addon.category || 'produce';
                    const colors = getCategoryColors(category);
                    
                    return `
                        <div class="addon-item" style="display: flex; align-items: center; padding: 12px; border-bottom: 1px solid #eee;">
                            <div class="item-details" style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div class="item-name" style="font-weight: 600;">${addon.item}</div>
                                    <div class="item-price" style="color: #2e7d32; font-weight: 600;">${addon.price || '$3.99'}</div>
                                </div>
                                <div class="item-meta" style="color: #666; font-size: 14px; margin-top: 2px;">${addon.reason}</div>
                            </div>
                            <span class="category-tag" style="
                                background: rgba(255, 255, 255, 0.7);
                                color: ${colors.text};
                                padding: 3px 9px;
                                border-radius: 10px;
                                font-size: 12px;
                                font-weight: 500;
                                text-align: center;
                                border: 1px solid rgba(0, 0, 0, 0.1);
                                display: inline-block;
                                opacity: 0.9;
                            ">${category}</span>
                        </div>
                    `;
                }).join('');
                document.getElementById('recommendedAddons').innerHTML = addonsHTML;
            } else {
                // No addons suggested
                document.getElementById('recommendedAddons').innerHTML = '<div style="color: #666; padding: 10px;">Your cart is complete!</div>';
            }
        }

        function updateSwapSuggestions(swaps) {
            // Update only the swaps display section
            console.log('üîÑ Updating swap suggestions:', swaps);

            if (swaps && swaps.length > 0) {
                const swapsHTML = swaps.map(swap => `
                    <div class="swap-suggestion">
                        <div class="swap-text">Swap ${swap.from} ‚Üí ${swap.to}</div>
                        <div class="swap-reason" style="font-size: 12px; color: #666; margin-top: 4px;">${swap.reason}</div>
                    </div>
                `).join('');
                document.getElementById('suggestedSwaps').innerHTML = swapsHTML;
            } else {
                document.getElementById('suggestedSwaps').innerHTML = '<div style="color: #666; padding: 10px;">No swaps needed - your selections look great!</div>';
            }
        }

        function updatePremiumAddons(addons) {
            // Update only the add-ons display section
            console.log('üîÑ Updating add-ons display:', addons);

            if (addons && addons.length > 0) {
                const addonsHTML = addons.map(addon => {
                    // Determine category and color using the same helper function
                    const category = addon.category || 'produce';
                    const colors = getCategoryColors(category);

                    return `
                        <div class="addon-item" style="display: flex; align-items: center; padding: 12px; border-bottom: 1px solid #eee;">
                            <div class="item-details" style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div class="item-name" style="font-weight: 600;">${addon.item}</div>
                                    <div class="item-price" style="color: #2e7d32; font-weight: 600;">${addon.price || '$3.99'}</div>
                                </div>
                                <div class="item-meta" style="color: #666; font-size: 14px; margin-top: 2px;">${addon.reason}</div>
                            </div>
                            <span class="category-tag" style="
                                background: rgba(255, 255, 255, 0.7);
                                color: ${colors.text};
                                padding: 3px 9px;
                                border-radius: 10px;
                                font-size: 12px;
                                font-weight: 500;
                                text-align: center;
                                border: 1px solid rgba(0, 0, 0, 0.1);
                                display: inline-block;
                                opacity: 0.9;
                            ">${category}</span>
                        </div>
                    `;
                }).join('');
                document.getElementById('recommendedAddons').innerHTML = addonsHTML;
            } else {
                // No addons suggested
                document.getElementById('recommendedAddons').innerHTML = '<div style="color: #666; padding: 10px;">Your cart is complete!</div>';
            }
        }

        function generateMealSuggestions(cartData) {
            // Analyze cart contents to suggest meals
            const proteins = [];
            const vegetables = [];
            
            // Extract proteins and vegetables from cart
            cartData.customizable_boxes?.forEach(box => {
                box.selected_items.forEach(item => {
                    if (item.name.includes('Chicken') || item.name.includes('Bass') || item.name.includes('Turkey')) {
                        proteins.push(item.name);
                    }
                    if (item.name.includes('Lettuce') || item.name.includes('Tomatoes') || 
                        item.name.includes('Peppers') || item.name.includes('Zucchini') || 
                        item.name.includes('Eggplant') || item.name.includes('Cucumbers')) {
                        vegetables.push(item.name);
                    }
                });
            });

            // Generate meal suggestions prioritizing dinner, then other meals
            const mealSuggestions = [
                {
                    name: "Pan-Seared Chicken + Cherry Tomato Salad",
                    time: 20,
                    protein: 35,
                    type: "Dinner",
                    servings: 2,
                    priority: 1
                },
                {
                    name: "Black Sea Bass + Grilled Vegetables",
                    time: 25,
                    protein: 28,
                    type: "Dinner", 
                    servings: 2,
                    priority: 1
                },
                {
                    name: "Stuffed Eggplant + Zucchini",
                    time: 35,
                    protein: 12,
                    type: "Lunch",
                    servings: 4,
                    priority: 2
                },
                {
                    name: "Avocado + Egg Breakfast Bowl",
                    time: 10,
                    protein: 18,
                    type: "Breakfast",
                    servings: 1,
                    priority: 3
                },
                {
                    name: "Cucumber + Pepper Fresh Salad",
                    time: 5,
                    protein: 6,
                    type: "Side",
                    servings: 2,
                    priority: 4
                }
            ];

            // Sort by priority (dinner first) and return top 4
            return mealSuggestions.sort((a, b) => a.priority - b.priority).slice(0, 4);
        }

        // Refresh meals button handler
        document.addEventListener('DOMContentLoaded', () => {
            const refreshButton = document.getElementById('refreshMeals');
            if (refreshButton) {
                refreshButton.addEventListener('click', debounceMealGeneration(async () => {
                    if (refreshesLeft > 0) {
                        // Disable button during refresh
                        refreshButton.disabled = true;
                        refreshButton.innerHTML = '‚è≥ Generating new meals...';
                        
                        try {
                            const timestamp = new Date().toISOString();
                            const phone = localStorage.getItem('userPhone');
                            console.log(`üîÑ [${timestamp}] Cart tab regenerating meals...`);
                            console.log(`üìä [MEAL DEBUG - CART] Request data:`, {
                                timestamp,
                                phone: phone,
                                mealPlanData: mealPlanData,
                                refreshesLeft: refreshesLeft
                            });

                            // Call API to regenerate meals
                            const apiRequestStart = Date.now();
                            const response = await fetch('/api/refresh-meals', {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({
                                    cart_data: mealPlanData,
                                    phone: phone
                                })
                            });

                            const apiRequestTime = Date.now() - apiRequestStart;
                            console.log(`‚è±Ô∏è [MEAL DEBUG - CART] API request took: ${apiRequestTime}ms`);

                            const data = await response.json();
                            console.log(`üì• [MEAL DEBUG - CART] API Response:`, {
                                success: data.success,
                                mealsCount: data.meals?.length || 0,
                                hasError: !!data.error,
                                responseTime: apiRequestTime + 'ms',
                                rawData: data
                            });
                            
                            if (data.success) {
                                // Update meal suggestions (no localStorage caching)
                                updateMealSuggestions(data.meals);
                                
                                // Decrement refresh count
                                refreshesLeft--;
                                localStorage.setItem('refreshesLeft', refreshesLeft);
                                
                                // Update button
                                if (refreshesLeft > 0) {
                                    refreshButton.disabled = false;
                                    refreshButton.innerHTML = `üîÑ Try Different Meals (${refreshesLeft} left)`;
                                } else {
                                    refreshButton.disabled = true;
                                    refreshButton.innerHTML = 'üîÑ No refreshes left';
                                    refreshButton.style.background = '#dee2e6';
                                }
                            } else {
                                // Re-enable on error
                                refreshButton.disabled = false;
                                refreshButton.innerHTML = `üîÑ Try Different Meals (${refreshesLeft} left)`;
                                alert('Failed to generate new meals. Please try again.');
                            }
                        } catch (error) {
                            console.error('Error refreshing meals:', error);
                            refreshButton.disabled = false;
                            refreshButton.innerHTML = `üîÑ Try Different Meals (${refreshesLeft} left)`;
                        }
                    }
                }));
            }
            
            // Load refresh count from localStorage
            const savedRefreshes = localStorage.getItem('refreshesLeft');
            if (savedRefreshes !== null) {
                refreshesLeft = parseInt(savedRefreshes);
                const refreshSpan = document.getElementById('refreshCount');
                if (refreshSpan) {
                    refreshSpan.textContent = refreshesLeft;
                }
            }
        });

        function updateMealSuggestions(meals) {
            // Update the meal suggestions container with new meals
            const container = document.getElementById('mealSuggestionsContainer');
            if (container && meals) {
                // Clear existing meals
                container.innerHTML = '';
                
                // Add new meals with enhanced information
                meals.forEach((meal, index) => {
                    const mealCard = document.createElement('div');
                    mealCard.className = meal.type === 'snack' ? 'meal-card snack' : 'meal-card';
                    
                    // Build ingredients list if available
                    const ingredientsText = meal.ingredients_used && meal.ingredients_used.length > 0 
                        ? `<div class="meal-ingredients">Uses: ${meal.ingredients_used.slice(0,3).join(', ')}</div>` 
                        : '';
                    
                    // Add note if present
                    const noteText = meal.note ? `<div class="meal-note">üí° ${meal.note}</div>` : '';
                    
                    // Show how many dinners this makes
                    const servingsText = meal.makes_x_dinners || `Serves ${meal.servings || 2}`;
                    
                    // Add type-specific emoji and formatting
                    const typeIcon = meal.type === 'snack' ? 'üçø' : 'ü•ò';
                    const typeLabel = meal.type === 'snack' ? 'Snack' : 'Meal';

                    mealCard.innerHTML = `
                        <div class="meal-header">
                            <span class="meal-name">${typeIcon} ${meal.name}</span>
                            <span class="meal-meta">${meal.time} ‚Ä¢ ${meal.protein}g protein ‚Ä¢ ${typeLabel}</span>
                        </div>
                        <div class="meal-servings">${servingsText}</div>
                        ${ingredientsText}
                        ${noteText}
                    `;
                    container.appendChild(mealCard);
                });
            }
        }

        async function generateMealSuggestionsFromAPI(cartData) {
            try {
                console.log('üçΩÔ∏è Calling GPT-5 API for meal suggestions...');
                
                // Show loading state
                document.getElementById('suggestedMeals').innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #666;">
                        ü§ñ GPT-5 is creating personalized meal suggestions...
                    </div>
                `;
                
                const response = await fetch('/api/refresh-meals', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        cart_data: cartData,
                        phone: getPhoneNumber()
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.meals && data.meals.length > 0) {
                    console.log('‚úÖ Got meal suggestions from GPT-5:', data.meals);
                    updateMealSuggestions(data.meals);
                } else {
                    console.error('‚ùå Meal generation failed:', data.error || 'Unknown error');
                    
                    // Show clear error message
                    document.getElementById('suggestedMeals').innerHTML = `
                        <div style="background: #fee; border: 1px solid #fcc; border-radius: 8px; padding: 16px; margin: 8px 0;">
                            <div style="color: #d00; font-weight: 600; margin-bottom: 8px;">
                                ‚ö†Ô∏è Meal Generation Error
                            </div>
                            <div style="color: #800; font-size: 14px;">
                                ${data.error || 'Unable to generate meal suggestions'}
                            </div>
                            ${data.debug_info ? `
                                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #fcc;">
                                    <div style="font-size: 12px; color: #666;">Debug Info:</div>
                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                        Proteins: ${data.debug_info.proteins_found?.length || 0} items<br>
                                        Vegetables: ${data.debug_info.vegetables_found?.length || 0} items<br>
                                        Error: ${data.debug_info.error_message || 'Unknown'}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                    
                    if (data.debug_info) {
                        console.log('Debug information:', data.debug_info);
                    }
                }
            } catch (error) {
                console.error('Error generating meal suggestions:', error);
                // Show error state
                document.getElementById('suggestedMeals').innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #666;">
                        Error generating meal suggestions. Please try refreshing.
                    </div>
                `;
            }
        }

        function displayMealSuggestions(meals) {
            console.log(`üìã Displaying ${meals.length} meal suggestions`);
            updateMealSuggestions(meals);
        }

        function showEmptyMealState() {
            const container = document.getElementById('mealSuggestionsContainer');
            if (container) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #666; border: 1px dashed #ddd; border-radius: 8px; margin: 8px 0;">
                        <div style="font-size: 16px; margin-bottom: 8px;">üçΩÔ∏è</div>
                        <div>Click "New Suggestions" to generate meal ideas</div>
                    </div>
                `;
            }
        }

        async function regenerateSwapsAndAddons(cartData) {
            try {
                console.log('üîÑ Generating new swaps and add-ons...');
                
                // For now, just call analyze-cart with regenerate flag
                // This will regenerate swaps and addons from the same cart
                const response = await fetch('/api/analyze-cart', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        phone: getPhoneNumber(),
                        use_mock: false,
                        regenerate_only: true  // Signal to skip scraping, just regenerate suggestions
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Update swaps display
                    if (data.swaps && data.swaps.length > 0) {
                        updateSwapSuggestions(data.swaps);
                    }

                    // Update add-ons display
                    if (data.addons && data.addons.length > 0) {
                        updatePremiumAddons(data.addons);
                    }

                    console.log('‚úÖ Regenerated swaps and add-ons successfully');
                }
            } catch (error) {
                console.error('Error generating swaps/addons:', error);
                // Don't alert here, let the main function handle errors
            }
        }

        async function regenerateAddonsOnly(cartData) {
            try {
                console.log('üîÑ Generating new add-ons (keeping swaps stable)...');

                // Call analyze-cart with regenerate flag to get new add-ons
                const response = await fetch('/api/analyze-cart', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        phone: getPhoneNumber(),
                        use_mock: false,
                        regenerate_only: true  // Signal to skip scraping, just regenerate suggestions
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Only update add-ons display (skip swaps to keep them stable)
                    if (data.addons && data.addons.length > 0) {
                        updatePremiumAddons(data.addons);
                        console.log('‚úÖ Regenerated add-ons successfully (swaps kept stable)');
                    }
                }
            } catch (error) {
                console.error('Error generating add-ons:', error);
                // Don't alert here, let the main function handle errors
            }
        }

        async function refreshSuggestions() {
            // Check for locked meals first
            if (FarmDashboard.MealLocking.hasLocks()) {
                const confirmed = confirm("‚ö†Ô∏è You have locked meals. This will reset ALL meals including locked ones. Continue?");
                if (!confirmed) {
                    return;
                }
                // Clear all locks since user confirmed
                await FarmDashboard.MealLocking.clearAll();
            }

            // Just regenerate meal suggestions without re-scraping cart
            const button = document.getElementById('refreshSuggestionsButton');
            const originalText = button.innerHTML;

            try {
                button.disabled = true;
                button.innerHTML = '‚è≥ Generating...';

                // Get cart data from global variable or fallback to API
                let cartData = null;
                if (mealPlanData && mealPlanData.cart_data) {
                    cartData = mealPlanData.cart_data;
                    console.log('üé≤ Using cart data from mealPlanData');
                } else {
                    // Fallback: fetch from API
                    console.log('üì¶ Fetching cart data from API...');
                    const response = await fetch('/api/get-saved-cart?force_refresh=false');
                    const data = await response.json();
                    if (data.cart_data) {
                        cartData = data.cart_data;
                        console.log('‚úÖ Retrieved cart data from API');
                    }
                }

                if (!cartData) {
                    alert('Please analyze your cart first');
                    return;
                }

                // Generate new meal suggestions from existing cart
                console.log('üé≤ Generating new meal suggestions from current cart');
                await generateMealSuggestionsFromAPI(cartData);

                // Also regenerate add-ons to complement new meals (keep swaps stable)
                await regenerateAddonsOnly(cartData);

            } catch (error) {
                console.error('Error refreshing suggestions:', error);
                alert('Failed to generate new suggestions. Please try again.');
            } finally {
                button.disabled = false;
                button.innerHTML = originalText;
                // Reset button styling to prevent stuck highlighting
                button.style.background = '#faf8f2';
                button.style.color = '#07261e';
            }
        }
        
        async function refreshCartData() {
            // Clear stored data to force fresh analysis
            localStorage.removeItem('cartAnalysisData');
            localStorage.removeItem('cartAnalysisState');
            
            const button = document.getElementById('refreshCartButton');
            const originalText = button.innerHTML;
            
            try {
                button.disabled = true;
                button.innerHTML = '‚è≥ Scraping FTP...';
                
                // Re-run full cart analysis with force refresh (including scraping)
                await FarmDashboard.Cart.startAnalysis(true);
                
            } catch (error) {
                console.error('Error refreshing cart:', error);
                alert('Failed to refresh cart data. Please try again.');
            } finally {
                button.disabled = false;
                button.innerHTML = originalText;
                // Reset button styling to prevent stuck highlighting
                button.style.background = '#faf8f2';
                button.style.color = '#07261e';
            }
        }
        
        // ===== SETTINGS FUNCTIONALITY =====
        
        async function loadUserSettings() {
            try {
                const userPhone = getPhoneNumber();
                const response = await fetch(`/api/settings/${userPhone}`);
                
                if (response.ok) {
                    const userData = await response.json();
                    displayUserSettings(userData);
                } else {
                    // Show fallback data from localStorage
                    displayFallbackSettings();
                }
            } catch (error) {
                console.error('Error loading user settings:', error);
                displayFallbackSettings();
            }
        }
        
        function displayUserSettings(userData) {
            const preferences = userData.preferences || {};
            
            // Account Information
            document.getElementById('userEmailDisplay').textContent = 
                localStorage.getItem('ftpEmail') || 'Not connected';
            document.getElementById('userPhoneDisplay').textContent = 
                formatPhoneNumber(getPhoneNumber()) || 'Not provided';
            
            // Household Information
            document.getElementById('householdSizeDisplay').textContent = 
                preferences.household_size || 'Not specified';
            document.getElementById('mealTimingDisplay').textContent = 
                preferences.meal_timing ? preferences.meal_timing.join(', ') : 'Not specified';
            
            // Meal Preferences
            document.getElementById('favoriteMealsDisplay').textContent = 
                preferences.selected_meals ? `${preferences.selected_meals.length} dishes selected` : 'None selected';
            document.getElementById('cookingMethodsDisplay').textContent = 
                preferences.cooking_methods ? preferences.cooking_methods.join(', ') : 'All methods';
            
            // Dietary Requirements
            const restrictions = preferences.dietary_restrictions || [];
            document.getElementById('dietaryRestrictionsDisplay').textContent = 
                restrictions.length > 0 ? restrictions.join(', ') : 'None specified';
            
            // Health Goals
            const goals = preferences.goals || [];
            document.getElementById('healthGoalsDisplay').textContent = 
                goals.length > 0 ? goals.join(', ') : 'None specified';
        }
        
        function displayFallbackSettings() {
            // Show basic info from localStorage if available
            document.getElementById('userEmailDisplay').textContent = 
                localStorage.getItem('ftpEmail') || 'Not connected';
            document.getElementById('userPhoneDisplay').textContent = 
                formatPhoneNumber(getPhoneNumber()) || 'Not provided';
            
            // Show placeholders for other fields
            document.getElementById('householdSizeDisplay').textContent = 'Complete onboarding to see preferences';
            document.getElementById('mealTimingDisplay').textContent = 'Complete onboarding to see preferences';
            document.getElementById('favoriteMealsDisplay').textContent = 'Complete onboarding to see preferences';
            document.getElementById('cookingMethodsDisplay').textContent = 'Complete onboarding to see preferences';
            document.getElementById('dietaryRestrictionsDisplay').textContent = 'Complete onboarding to see preferences';
            document.getElementById('healthGoalsDisplay').textContent = 'Complete onboarding to see preferences';
        }
        
        function formatPhoneNumber(phone) {
            if (!phone) return '';
            // Format as (XXX) XXX-XXXX
            const cleaned = phone.replace(/\D/g, '');
            if (cleaned.length === 10) {
                return `(${cleaned.slice(0,3)}) ${cleaned.slice(3,6)}-${cleaned.slice(6)}`;
            }
            return phone;
        }
        
        async function refreshUserPreferences() {
            const button = event.currentTarget.querySelector('[style*="cursor: pointer"]');
            const originalText = button.textContent;
            
            try {
                button.textContent = '‚è≥ Loading...';
                await loadUserSettings();
                button.textContent = '‚úì Updated';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            } catch (error) {
                console.error('Error refreshing settings:', error);
                button.textContent = '‚ùå Error';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            }
        }
        
        function updateAccountCredentials() {
            const newEmail = prompt('Enter your new Farm to People email:', localStorage.getItem('ftpEmail') || '');
            if (!newEmail) return;
            
            const newPassword = prompt('Enter your new Farm to People password:');
            if (!newPassword) return;
            
            // Update localStorage
            localStorage.setItem('ftpEmail', newEmail);
            localStorage.setItem('ftpPassword', newPassword);
            
            // Update display
            document.getElementById('userEmailDisplay').textContent = newEmail;
            document.querySelector('.subtitle').textContent = newEmail;
            
            alert('Account credentials updated successfully!');
        }
        
        function updateMealSuggestions(meals) {
            const mealsHTML = meals.map((meal, index) => {
                // Determine if it's a snack
                const isSnack = meal.type === 'snack';

                // Check if this meal is locked
                const isLocked = FarmDashboard.MealLocking.state.locked[index] || false;

                // Update colors based on snack type and lock status
                let bgColor, borderColor, textColor;
                if (isLocked) {
                    bgColor = '#e3f2fd';  // Light blue for locked meals
                    borderColor = '#1976d2';  // Darker blue border
                    textColor = '#1976d2';  // Blue text
                } else if (isSnack) {
                    bgColor = '#f9f7f1';  // Subtle warm cream for snacks
                    borderColor = '#d6d3d1';  // Muted border for snacks
                    textColor = '#b45309';  // Darker yellow-orange for snacks
                } else {
                    bgColor = '#f0f8f0';  // Green for meals
                    borderColor = '#4169E1';  // Blue border for meals
                    textColor = '#4169E1';  // Blue text for meals
                }

                const typeLabel = isSnack ? 'snack' : 'meal';
                const lockIcon = isLocked ? 'üîí ' : '';

                return `
                    <div class="cart-item" style="background: ${bgColor}; border-left: 3px solid ${borderColor};" data-meal-index="${index}">
                        <div class="item-details">
                            <div class="item-name" style="color: ${textColor}; font-weight: 600;">
                                ${lockIcon}${meal.name}
                            </div>
                            <div class="item-meta">${meal.time} ‚Ä¢ ${meal.protein || '0'}g protein ‚Ä¢ ${typeLabel}${isLocked ? ' ‚Ä¢ locked' : ''}</div>
                        </div>
                        <div style="font-size: 12px; color: #6c757d;">Serves ${meal.servings || 2}</div>
                    </div>
                `;
            }).join('');
            document.getElementById('suggestedMeals').innerHTML = mealsHTML;

            // Also update Meals tab with the first meal if we have one
            if (meals && meals.length > 0) {
                try {
                    if (typeof populateSimpleMealCard === 'function') {
                        populateSimpleMealCard(meals[0]);
                    }
                } catch (e) {
                    console.log('Note: Could not sync to Meals tab:', e.message);
                }
            }
        }

        function switchTab(tab, element) {
            console.log('üîÑ Switching to tab:', tab);

            // Special handling for settings - open modal instead
            if (tab === 'settings') {
                openSettingsModal();
                return; // Don't do normal tab switching
            }

            // Update active tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            element.classList.add('active');

            // Hide all tab contents first
            document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));

            // Hide all sections
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));

            // Show the correct tab content
            if (tab === 'cart') {
                console.log('üì¶ Showing cart tab content');
                document.getElementById('boxTab').classList.add('active');
            } else if (tab === 'meals') {
                console.log('üçΩÔ∏è Showing meals tab content');
                document.getElementById('planTab').classList.add('active');
            }

            // Show the right section based on state and tab
            if (tab === 'cart') {
                // Cart tab shows saved data or allows new analysis
                if (currentState === 'complete') {
                    document.getElementById('cartAnalysisSection').classList.add('active');
                } else if (currentState === 'loading') {
                    document.getElementById('loadingSection').classList.add('active');
                } else {
                    // Try to load saved cart data first
                    FarmDashboard.Cart.loadSavedCartData().then(loaded => {
                        if (!loaded) {
                            // No saved data, show the start screen
                            document.getElementById('startSection').classList.add('active');
                        }
                    });
                }
            } else if (tab === 'meals') {
                // Meals tab shows meal suggestions
                document.getElementById('mealsSection').classList.add('active');

                // Always show meal grid - let syncMealsFromCart handle Redis fetching
                const hasMeals = true; // Always try to sync from Redis first

                console.log('üîç Debug Meals Tab: Always showing meal grid, will fetch from Redis');

                if (hasMeals) {
                    // Show meal locking grid interface
                    document.getElementById('simpleMealCardContainer').style.display = 'block';
                    document.getElementById('mealPlanEmpty').style.display = 'none';
                    document.getElementById('mealCalendarGrid').style.display = 'none';

                    // Sync meals from Cart tab to Meals tab
                    console.log('üîÑ Syncing meals to locking grid...');
                    setTimeout(() => {
                        FarmDashboard.Meals.syncFromCart();
                    }, 100);
                } else {
                    // Show empty state only if truly no meals available
                    document.getElementById('simpleMealCardContainer').style.display = 'none';
                    document.getElementById('mealPlanEmpty').style.display = 'block';
                    document.getElementById('mealCalendarGrid').style.display = 'none';
                }
            }
            
            // Show header banner for cart and meals tabs
            if (tab === 'cart' || tab === 'meals') {
                document.querySelector('.header').style.display = 'block';
            }
        }

        // New function to open settings as modal with iframe
        function openSettingsModal() {
            console.log('üîß openSettingsModal called - using iframe approach');

            // Remove existing modal if it exists
            const existingModal = document.getElementById('settingsModalOverlay');
            if (existingModal) {
                existingModal.remove();
            }

            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'settingsModalOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.7);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;

            // Create modal container
            const modal = document.createElement('div');
            modal.id = 'settingsModalWrapper';
            modal.style.cssText = `
                background: white;
                width: 100%;
                max-width: 800px;
                height: 90vh;
                border-radius: 16px;
                position: relative;
                overflow: hidden;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            `;

            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '√ó';
            closeBtn.style.cssText = `
                position: absolute;
                top: 15px;
                right: 20px;
                background: rgba(255,255,255,0.9);
                border: none;
                font-size: 24px;
                cursor: pointer;
                color: #666;
                line-height: 1;
                width: 32px;
                height: 32px;
                border-radius: 50%;
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: background-color 0.2s ease;
            `;
            closeBtn.onmouseover = () => closeBtn.style.backgroundColor = 'rgba(255,255,255,1)';
            closeBtn.onmouseout = () => closeBtn.style.backgroundColor = 'rgba(255,255,255,0.9)';
            closeBtn.onclick = closeSettingsModal;

            // Create iframe for settings page
            const iframe = document.createElement('iframe');
            const phone = localStorage.getItem('userPhone') || getPhoneNumber();
            iframe.src = `/settings?phone=${phone}&iframe=true`;
            iframe.style.cssText = `
                width: 100%;
                height: 100%;
                border: none;
                border-radius: 16px;
            `;

            // Add loading message while iframe loads
            const loadingDiv = document.createElement('div');
            loadingDiv.innerHTML = `
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                    <div style="margin-bottom: 16px; font-size: 18px; color: #666;">Loading Settings...</div>
                    <div style="width: 40px; height: 40px; border: 3px solid #f3f3f3; border-top: 3px solid #007AFF; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;

            modal.appendChild(loadingDiv);
            modal.appendChild(iframe);
            modal.appendChild(closeBtn);

            // Hide loading message once iframe loads
            iframe.onload = () => {
                console.log('üîß Settings iframe loaded successfully');
                loadingDiv.style.display = 'none';
            };

            overlay.appendChild(modal);

            // Close on overlay click (but not on modal click)
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    closeSettingsModal();
                }
            };

            // Prevent modal clicks from closing
            modal.onclick = (e) => {
                e.stopPropagation();
            };

            document.body.appendChild(overlay);
            console.log('üîß Settings modal with iframe created');
        }

        function closeSettingsModal() {
            console.log('üîß Closing settings modal');
            const overlay = document.getElementById('settingsModalOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        function updateWeekDates() {
            const today = new Date();
            const monday = new Date(today);
            monday.setDate(today.getDate() - today.getDay() + 1);
            
            const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
            days.forEach((day, index) => {
                const date = new Date(monday);
                date.setDate(monday.getDate() + index);
                const dateElement = document.getElementById(`${day}-date`);
                if (dateElement) {
                    dateElement.textContent = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                }
            });
        }
        
        // Initialize meal plan with proper ingredient tracking
        function initializeMealPlanFromCart() {
            if (!mealPlanData || !mealPlanData.cart_data) return;
            
            const cartData = mealPlanData.cart_data;
            
            // Build ingredient pool from cart data
            const ingredientPool = {};
            
            // Process individual items
            if (cartData.individual_items) {
                cartData.individual_items.forEach(item => {
                    ingredientPool[item.name] = {
                        total: item.quantity || 1,
                        allocated: 0,
                        remaining: item.quantity || 1,
                        unit: item.unit || 'piece'
                    };
                });
            }
            
            // Process box items
            ['customizable_boxes', 'non_customizable_boxes'].forEach(boxType => {
                if (cartData[boxType]) {
                    cartData[boxType].forEach(box => {
                        if (box.selected_items) {
                            box.selected_items.forEach(item => {
                                const name = item.name;
                                if (ingredientPool[name]) {
                                    ingredientPool[name].total += (item.quantity || 1);
                                    ingredientPool[name].remaining += (item.quantity || 1);
                                } else {
                                    ingredientPool[name] = {
                                        total: item.quantity || 1,
                                        allocated: 0,
                                        remaining: item.quantity || 1,
                                        unit: item.unit || 'piece'
                                    };
                                }
                            });
                        }
                    });
                }
            });
            
            // Store the meal plan structure
            mealPlanData.meal_plan = {
                ingredient_pool: ingredientPool,
                meals: {}
            };
            
            // Render the ingredient pool with actual tracking
            renderIngredientPool(ingredientPool);
            
            // Create sample meals with ingredient allocation (temporary until API generates real meals)
            generateSampleMealsWithIngredients();
        }
        
        // Generate sample meals with proper ingredient allocation
        function generateSampleMealsWithIngredients() {
            if (!mealPlanData.meal_plan) return;
            
            const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
            const sampleMeals = [
                { name: 'High-Protein Chicken Stir-Fry', protein: '38g', cook_time: '25 min', servings: 2 },
                { name: 'Mediterranean Quinoa Bowl', protein: '32g', cook_time: '30 min', servings: 2 },
                { name: 'Grass-Fed Beef Tacos', protein: '35g', cook_time: '20 min', servings: 4 },
                { name: 'Salmon & Roasted Vegetables', protein: '40g', cook_time: '35 min', servings: 2 },
                { name: 'Turkey Meatball Pasta', protein: '36g', cook_time: '30 min', servings: 3 }
            ];
            
            const pool = mealPlanData.meal_plan.ingredient_pool;
            const availableIngredients = Object.keys(pool).filter(ing => pool[ing].remaining > 0);
            
            days.forEach((day, index) => {
                const meal = sampleMeals[index % sampleMeals.length];
                const allocatedIngredients = [];
                
                // Allocate 2-3 random ingredients to each meal
                const numIngredients = Math.min(3, availableIngredients.length);
                for (let i = 0; i < numIngredients && availableIngredients.length > 0; i++) {
                    const ingIndex = Math.floor(Math.random() * availableIngredients.length);
                    const ingName = availableIngredients[ingIndex];
                    const ingredient = pool[ingName];
                    
                    if (ingredient.remaining > 0) {
                        const amount = Math.min(1, ingredient.remaining);
                        ingredient.allocated += amount;
                        ingredient.remaining -= amount;
                        
                        allocatedIngredients.push({
                            name: ingName,
                            amount: amount,
                            unit: ingredient.unit
                        });
                        
                        // Remove ingredient if fully allocated
                        if (ingredient.remaining <= 0) {
                            availableIngredients.splice(ingIndex, 1);
                        }
                    }
                }
                
                mealPlanData.meal_plan.meals[day] = {
                    id: `meal-${day}-${Date.now()}`,
                    meal_data: meal,
                    allocated_ingredients: allocatedIngredients
                };
                
                // Render the meal card
                renderMealCard(day, mealPlanData.meal_plan.meals[day]);
            });
            
            // Update ingredient pool display
            renderIngredientPool(pool);
        }
        
        // Render the full meal plan
        function renderFullMealPlan(mealPlan) {
            if (!mealPlan) return;
            
            // Render each meal
            if (mealPlan.meals) {
                Object.entries(mealPlan.meals).forEach(([day, meal]) => {
                    renderMealCard(day, meal);
                });
            }
            
            // Render ingredient pool
            if (mealPlan.ingredient_pool) {
                renderIngredientPool(mealPlan.ingredient_pool);
            }
        }
        
        function showAddToHomeScreen() {
            // iOS Safari
            if (navigator.userAgent.match(/iPhone|iPad|iPod/)) {
                alert('Tap the Share button (‚ÜóÔ∏è) at the bottom of Safari, then tap "Add to Home Screen"');
            } 
            // Android Chrome
            else if (navigator.userAgent.match(/Android/)) {
                alert('Tap the menu (‚ãÆ) in Chrome, then tap "Add to Home screen"');
            } 
            else {
                alert('Use your browser\'s menu to add this page to your home screen');
            }
        }

        // Save credentials when they complete onboarding (called from onboarding.js)
        window.saveUserCredentials = function(email, password) {
            localStorage.setItem('ftpEmail', email);
            localStorage.setItem('ftpPassword', password);
        }

        // ===== MEAL CALENDAR FUNCTIONALITY =====
        
        // Initialize to current date (will be set to Monday in initMealCalendar)
        let currentWeek = new Date();
        let currentMealPlan = null;
        let draggedMeal = null;
        
        // Initialize calendar when meals tab is clicked
        function initMealCalendar() {
            console.log('üçΩÔ∏è Initializing meal calendar');
            
            // Try to get delivery date from cart data to determine meal planning week
            const savedAnalysis = localStorage.getItem('cartAnalysisData');
            let targetDate = new Date(); // Default to current date
            
            if (savedAnalysis) {
                try {
                    const { cartData } = JSON.parse(savedAnalysis);
                    const deliveryInfo = cartData?.delivery_info;
                    
                    if (deliveryInfo && deliveryInfo.delivery_text) {
                        // Parse delivery date: "Shopping for: Sun, Aug 31, 10:00AM - 4:00PM"
                        console.log(`üîç Parsing delivery text: "${deliveryInfo.delivery_text}"`);
                        const match = deliveryInfo.delivery_text.match(/Shopping for: .+?(\w{3}), (\w{3}) (\d{1,2})/);
                        if (match) {
                            const month = match[2]; // "Aug"
                            const day = parseInt(match[3]); // 31
                            const currentYear = new Date().getFullYear();
                            
                            console.log(`üóìÔ∏è Parsed: ${month} ${day}, ${currentYear}`);
                            
                            // Convert month abbreviation to month number
                            const months = {
                                'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
                                'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
                            };
                            
                            if (months[month] !== undefined) {
                                const deliveryDate = new Date(currentYear, months[month], day);
                                
                                // If the delivery date is in the past (more than 7 days ago), it's probably next year
                                const today = new Date();
                                const daysDiff = Math.floor((today - deliveryDate) / (1000 * 60 * 60 * 24));
                                if (daysDiff > 7) {
                                    deliveryDate.setFullYear(currentYear + 1);
                                }
                                
                                console.log(`üì¶ Delivery date: ${deliveryDate.toDateString()}`);
                                
                                // For Sunday delivery, meal planning week starts Monday
                                // Sunday Aug 31 -> Week of Sept 1-5
                                if (deliveryDate.getDay() === 0) { // Sunday
                                    targetDate = new Date(deliveryDate);
                                    targetDate.setDate(deliveryDate.getDate() + 1); // Monday Sept 1
                                    console.log(`üìÖ Sunday delivery, meal week starts Monday: ${targetDate.toDateString()}`);
                                } else {
                                    // For other days, start the following Monday
                                    targetDate = new Date(deliveryDate);
                                    const daysUntilMonday = (8 - deliveryDate.getDay()) % 7;
                                    targetDate.setDate(deliveryDate.getDate() + daysUntilMonday);
                                    console.log(`üìÖ ${['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][deliveryDate.getDay()]} delivery, meal week starts: ${targetDate.toDateString()}`);
                                }
                            } else {
                                console.log(`‚ùå Unknown month: ${month}`);
                            }
                        } else {
                            console.log(`‚ùå Could not parse delivery text: "${deliveryInfo.delivery_text}"`);
                        }
                    } else {
                        console.log('‚ÑπÔ∏è No delivery info found, using current date');
                    }
                } catch (e) {
                    console.log('Could not parse delivery date, using current date');
                }
            }
            
            // Initialize currentWeek to the Monday of the target week
            console.log(`üìÖ Target date for meals: ${targetDate.toDateString()} (Day: ${targetDate.getDay()})`);
            
            // Ensure we have the correct Monday for the meal planning week
            currentWeek = getMonday(targetDate);
            console.log(`üìÖ Meal planning week Monday: ${currentWeek.toDateString()}`);
            console.log(`üìÖ Week string will be: ${getWeekString(currentWeek)}`);
            
            updateWeekDisplay();
            loadCurrentWeekPlan();
            setupEventListeners();
        }
        
        function setupEventListeners() {
            // Week navigation
            document.getElementById('prevWeek').addEventListener('click', () => {
                changeWeek(-1);
            });
            
            document.getElementById('nextWeek').addEventListener('click', () => {
                changeWeek(1);
            });
            
            // PDF generation
            document.getElementById('generatePDF').addEventListener('click', generateMealPlanPDF);
            
            // Auto-fill week
            document.getElementById('autoFillWeek').addEventListener('click', autoFillWeek);
            
            // Create meal plan (only if element exists)
            const createMealPlanBtn = document.getElementById('createMealPlan');
            if (createMealPlanBtn) {
                createMealPlanBtn.addEventListener('click', createNewMealPlan);
            }
            
            // Retry loading
            document.getElementById('retryLoad').addEventListener('click', loadCurrentWeekPlan);
            
            // Setup drag and drop
            setupDragAndDrop();
        }
        
        function getWeekString(date) {
            const monday = getMonday(date);
            return monday.toISOString().split('T')[0];
        }
        
        function getMonday(date) {
            const d = new Date(date);
            const day = d.getDay();
            
            // If it's already Monday, return it
            if (day === 1) {
                return new Date(d);
            }
            
            // If it's Sunday, go to next Monday
            if (day === 0) {
                const monday = new Date(d);
                monday.setDate(d.getDate() + 1);
                return monday;
            }
            
            // For other days, go to the Monday of that week
            const diff = d.getDate() - day + 1;
            const monday = new Date(d);
            monday.setDate(diff);
            return monday;
        }
        
        function updateWeekDisplay() {
            const monday = getMonday(currentWeek);
            const friday = new Date(monday);
            friday.setDate(friday.getDate() + 4);
            
            // Update the subtitle to show the date range
            const weekString = `${monday.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric'
            })} - ${friday.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric'
            })}`;
            
            document.getElementById('weekDisplay').textContent = weekString;
            
            // Update day dates
            const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
            days.forEach((day, index) => {
                const dayDate = new Date(monday);
                dayDate.setDate(dayDate.getDate() + index);
                const dateElement = document.getElementById(`${day}-date`);
                if (dateElement) {
                    dateElement.textContent = dayDate.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric' 
                    });
                }
            });
        }
        
        function changeWeek(direction) {
            // Create a new date to avoid mutation issues
            const newWeek = new Date(currentWeek);
            newWeek.setDate(newWeek.getDate() + (direction * 7));
            currentWeek = newWeek;
            updateWeekDisplay();
            loadCurrentWeekPlan();
        }
        
        async function loadCurrentWeekPlan() {
            console.log('üìÖ Loading meal plan for week:', getWeekString(currentWeek));
            showLoading();
            
            try {
                const phone = getPhoneNumber();
                if (!phone) {
                    showEmpty();
                    return;
                }
                
                const weekString = getWeekString(currentWeek);
                // DISABLED: This endpoint doesn't exist and causes 404 errors
                console.log('‚ÑπÔ∏è Skipping deprecated meal-plans API call');
                showEmpty();
                return;
                // const response = await fetch(`/api/meal-plans/${phone}/${weekString}`);
                
                // if (response.status === 404) {
                //     showEmpty();
                //     return;
                // }
                //
                // if (!response.ok) {
                //     throw new Error(`HTTP ${response.status}`);
                // }
                //
                // const mealPlan = await response.json();
                // currentMealPlan = mealPlan;
                // renderMealPlan(mealPlan);
                
            } catch (error) {
                console.error('Error loading meal plan:', error);
                showError();
            }
        }
        
        function getPhoneNumber() {
            // Try to get phone number from various sources
            const urlParams = new URLSearchParams(window.location.search);
            let phone = urlParams.get('phone');
            
            if (!phone) {
                phone = localStorage.getItem('userPhone');
            }
            
            // Fix truncated phone number issue
            if (phone === '425495323') {
                phone = '4254955323';
                // Update localStorage with correct number
                localStorage.setItem('userPhone', phone);
            }
            
            if (!phone) {
                // Try to extract from stored credentials or other sources
                phone = '4254955323'; // Default for testing
            }
            
            // Ensure consistent format (no +1)
            if (phone.startsWith('+1')) {
                phone = phone.substring(2);
            } else if (phone.startsWith('+')) {
                phone = phone.substring(1);
            } else if (phone.startsWith('1') && phone.length === 11) {
                phone = phone.substring(1);
            }
            
            return phone;
        }
        
        function showLoading() {
            document.getElementById('mealPlanLoading').style.display = 'block';
            document.getElementById('mealPlanError').style.display = 'none';
            document.getElementById('simpleMealCardContainer').style.display = 'none';
            document.getElementById('mealPlanEmpty').style.display = 'none';
            document.getElementById('mealCalendarGrid').style.display = 'none';
        }

        function showError() {
            document.getElementById('mealPlanLoading').style.display = 'none';
            document.getElementById('mealPlanError').style.display = 'block';
            document.getElementById('simpleMealCardContainer').style.display = 'none';
            document.getElementById('mealPlanEmpty').style.display = 'none';
            document.getElementById('mealCalendarGrid').style.display = 'none';
        }

        function showEmpty() {
            document.getElementById('mealPlanLoading').style.display = 'none';
            document.getElementById('mealPlanError').style.display = 'none';
            document.getElementById('simpleMealCardContainer').style.display = 'none';
            document.getElementById('mealPlanEmpty').style.display = 'block';
            document.getElementById('mealCalendarGrid').style.display = 'none';
        }

        function showMealCard() {
            document.getElementById('mealPlanLoading').style.display = 'none';
            document.getElementById('mealPlanError').style.display = 'none';
            document.getElementById('simpleMealCardContainer').style.display = 'block';
            document.getElementById('mealPlanEmpty').style.display = 'none';
            document.getElementById('mealCalendarGrid').style.display = 'none';
        }

        function showCalendar() {
            document.getElementById('mealPlanLoading').style.display = 'none';
            document.getElementById('mealPlanError').style.display = 'none';
            document.getElementById('simpleMealCardContainer').style.display = 'none';
            document.getElementById('mealPlanEmpty').style.display = 'none';
            document.getElementById('mealCalendarGrid').style.display = 'grid';
        }
        
        function renderMealPlan(mealPlan) {
            console.log('üé® Rendering meal plan:', mealPlan);
            
            showCalendar();
            updateWeekDisplay();
            
            // Clear existing meals
            const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
            days.forEach(day => {
                const mealSlot = document.querySelector(`[data-day="${day}"] .meal-slot`);
                if (mealSlot) {
                    mealSlot.innerHTML = `
                        <div class="add-meal-prompt">
                            <span class="add-icon">+</span>
                            <span>Add Meal</span>
                        </div>
                    `;
                }
            });
            
            // Render meals
            if (mealPlan.meals) {
                Object.entries(mealPlan.meals).forEach(([day, meal]) => {
                    renderMealCard(day, meal);
                });
            }
            
            // Render ingredients
            renderIngredientPool(mealPlan.ingredient_pool || {});
        }
        
        function renderMealCard(day, meal) {
            const mealSlot = document.querySelector(`[data-day="${day}"] .meal-slot`);
            if (!mealSlot) return;
            
            const mealData = meal.meal_data || {};
            const ingredients = meal.allocated_ingredients || [];
            
            const ingredientChips = ingredients.map(ing => 
                `<span class="ingredient-chip">${ing.name}</span>`
            ).join('');
            
            mealSlot.innerHTML = `
                <div class="meal-card" draggable="true" data-meal-id="${meal.id}" data-day="${day}">
                    <div class="meal-header">
                        <div class="meal-name">${mealData.name || 'Unnamed Meal'}</div>
                        <span class="protein-badge">${mealData.protein || '25g'} protein</span>
                    </div>
                    <div class="meal-details">
                        <span>${mealData.cook_time || '30 min'} ‚Ä¢ ${mealData.servings || 2} servings</span>
                    </div>
                    <div class="ingredients-used">
                        ${ingredientChips}
                    </div>
                    <div class="meal-actions">
                        <button class="meal-action-btn regenerate" onclick="regenerateMeal('${day}')">üîÑ</button>
                        <button class="meal-action-btn remove" onclick="removeMeal('${day}')">‚ùå</button>
                    </div>
                </div>
            `;
        }
        
        function renderIngredientPool(ingredientPool) {
            const ingredientList = document.getElementById('ingredientList');
            if (!ingredientList) return;
            
            const ingredientItems = Object.entries(ingredientPool).map(([name, info]) => {
                const usedPercent = (info.allocated / info.total) * 100;
                const remainingAmount = info.remaining;
                
                return `
                    <div class="ingredient-item">
                        <div class="ingredient-name">${name}</div>
                        <div class="ingredient-progress">
                            <div class="ingredient-progress-bar" style="width: ${usedPercent}%"></div>
                        </div>
                        <div class="ingredient-status">
                            <span>${remainingAmount} ${info.unit} left</span>
                            <span>${Math.round(usedPercent)}% used</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            ingredientList.innerHTML = ingredientItems;
        }
        
        function setupDragAndDrop() {
            // Handle drag start
            document.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('meal-card')) {
                    draggedMeal = {
                        element: e.target,
                        day: e.target.dataset.day,
                        mealId: e.target.dataset.mealId
                    };
                    e.target.classList.add('dragging');
                }
            });
            
            // Handle drag end
            document.addEventListener('dragend', (e) => {
                if (e.target.classList.contains('meal-card')) {
                    e.target.classList.remove('dragging');
                }
                draggedMeal = null;
            });
            
            // Handle drag over
            document.addEventListener('dragover', (e) => {
                e.preventDefault();
                const mealSlot = e.target.closest('.meal-slot');
                if (mealSlot) {
                    const dayColumn = mealSlot.closest('.day-column');
                    if (dayColumn) {
                        dayColumn.classList.add('drag-over');
                    }
                }
            });
            
            // Handle drag leave
            document.addEventListener('dragleave', (e) => {
                const dayColumn = e.target.closest('.day-column');
                if (dayColumn) {
                    dayColumn.classList.remove('drag-over');
                }
            });
            
            // Handle drop
            document.addEventListener('drop', (e) => {
                e.preventDefault();
                
                const mealSlot = e.target.closest('.meal-slot');
                if (mealSlot && draggedMeal) {
                    const newDay = mealSlot.closest('.day-column').dataset.day;
                    
                    // Remove drag-over styling
                    document.querySelectorAll('.day-column').forEach(col => {
                        col.classList.remove('drag-over');
                    });
                    
                    if (newDay !== draggedMeal.day) {
                        moveMeal(draggedMeal.day, newDay, draggedMeal.mealId);
                    }
                }
            });
        }
        
        async function moveMeal(fromDay, toDay, mealId) {
            console.log(`üîÑ Moving meal from ${fromDay} to ${toDay}`);
            
            try {
                // Remove meal from old day
                // DISABLED: This endpoint doesn't exist and causes 404 errors
                console.log('‚ÑπÔ∏è Skipping deprecated meal-plans DELETE API call');
                // await fetch(`/api/meal-plans/${currentMealPlan.id}/meals/${fromDay}`, {
                //     method: 'DELETE'
                // });
                
                // Get meal data for reassignment
                const mealCard = document.querySelector(`[data-meal-id="${mealId}"]`);
                if (!mealCard) return;
                
                // For now, just reload the plan
                // TODO: Implement proper meal reassignment
                setTimeout(() => {
                    loadCurrentWeekPlan();
                }, 500);
                
            } catch (error) {
                console.error('Error moving meal:', error);
                // Reload to show current state
                loadCurrentWeekPlan();
            }
        }
        
        async function regenerateMeal(day) {
            console.log(`üîÑ Regenerating meal for ${day}`);
            
            try {
                // DISABLED: This endpoint doesn't exist and causes 404 errors
                console.log('‚ÑπÔ∏è Skipping deprecated meal-plans regenerate API call');
                return;
                // const response = await fetch(`/api/meal-plans/${currentMealPlan.id}/meals/${day}/regenerate`, {
                //     method: 'POST',
                //     headers: {
                //         'Content-Type': 'application/json'
                //     },
                //     body: JSON.stringify({
                //         day: day,
                //         preferences: {}
                //     })
                // });
                
                // if (response.ok) {
                //     // Show loading for this day
                //     const mealSlot = document.querySelector(`[data-day="${day}"] .meal-slot`);
                //     if (mealSlot) {
                //         mealSlot.innerHTML = '<div class="spinner"></div>';
                //     }
                //
                //     // Reload after a few seconds
                //     setTimeout(() => {
                //         loadCurrentWeekPlan();
                //     }, 3000);
                // }
                
            } catch (error) {
                console.error('Error regenerating meal:', error);
            }
        }
        
        async function removeMeal(day) {
            if (!confirm(`Remove meal for ${day}?`)) return;
            
            console.log(`‚ùå Removing meal for ${day}`);
            
            try {
                // DISABLED: This endpoint doesn't exist and causes 404 errors
                console.log('‚ÑπÔ∏è Skipping deprecated meal-plans remove API call');
                return;
                // const response = await fetch(`/api/meal-plans/${currentMealPlan.id}/meals/${day}`, {
                //     method: 'DELETE'
                // });
                
                // if (response.ok) {
                //     loadCurrentWeekPlan();
                // }
                
            } catch (error) {
                console.error('Error removing meal:', error);
            }
        }
        
        async function createNewMealPlan() {
            console.log('üÜï Creating new meal plan');
            
            if (!mealPlanData || !mealPlanData.cart_data) {
                alert('Please analyze your cart first to create a meal plan');
                // switchTab('cart'); // DISABLED - this function needs element parameter
                return;
            }
            
            try {
                const phone = getPhoneNumber();
                const weekString = getWeekString(currentWeek);
                
                // DISABLED: This endpoint doesn't exist and causes 404 errors
                console.log('‚ÑπÔ∏è Skipping deprecated meal-plans create API call');
                return;
                // const response = await fetch('/api/meal-plans/', {
                //     method: 'POST',
                //     headers: {
                //         'Content-Type': 'application/json'
                //     },
                //     body: JSON.stringify({
                //         user_phone: phone,
                //         week_of: weekString,
                //         cart_data: mealPlanData.cart_data
                //     })
                // });
                //
                // if (response.ok) {
                //     showLoading();
                //     // Wait a bit for background processing
                //     setTimeout(() => {
                //         loadCurrentWeekPlan();
                //     }, 5000);
                // } else {
                //     throw new Error(`HTTP ${response.status}`);
                // }
                
            } catch (error) {
                console.error('Error creating meal plan:', error);
                alert('Failed to create meal plan. Please try again.');
            }
        }
        
        async function autoFillWeek() {
            console.log('üéØ Auto-filling week with meals');
            // For now, just create a new meal plan
            await createNewMealPlan();
        }
        
        function generateMealPlanPDF() {
            console.log('üìÑ Generating meal plan PDF');
            if (currentMealPlan) {
                // TODO: Implement PDF generation
                alert('PDF generation coming soon!');
            }
        }
        
        // Enhanced switchTab function to initialize calendar and meal locking
        const originalSwitchTab = switchTab;
        window.switchTab = function(tab, element) {
            originalSwitchTab(tab, element);

            if (tab === 'meals') {
                // Initialize calendar and meal locking interface when switching to meals tab
                setTimeout(async () => {
                    // initMealCalendar(); // DISABLED: Causes competing views - only use clean card view
                    // await initializeMealLockingInterface(); // DISABLED: Causes competing views with syncMealsFromCart()

                    // Final safety check: if still no meals after initialization, generate them
                    if (!currentMealSuggestions || currentMealSuggestions.length === 0) {
                        console.log('üõ°Ô∏è Safety check: No meals found after initialization, triggering generation...');
                        try {
                            await generateMealSuggestions();
                        } catch (e) {
                            console.error('‚ùå Safety generation failed:', e);
                        }
                    } else {
                        console.log('‚úÖ Meals tab ready with', currentMealSuggestions.length, 'meals');
                    }
                }, 100);
            }
        };
        
        // Settings Management
        let currentUserSettings = {};
        let settingsOptions = {};
        let currentEditCategory = null;
        
        async function loadUserSettings() {
            const phone = localStorage.getItem('userPhone') || '4254955323';
            document.getElementById('settingsLoading').style.display = 'block';
            document.getElementById('settingsCategories').style.display = 'none';
            
            try {
                // Load user preferences
                const userResponse = await fetch(`/api/settings/${phone}`);
                const userData = await userResponse.json();
                currentUserSettings = userData;
                
                // Load available options
                const optionsResponse = await fetch('/api/settings/options');
                settingsOptions = await optionsResponse.json();
                
                // Display settings
                displaySettings();
            } catch (error) {
                console.error('Error loading settings:', error);
                document.getElementById('settingsCategories').innerHTML = '<p style="text-align: center; color: #dc3545;">Failed to load settings</p>';
            } finally {
                document.getElementById('settingsLoading').style.display = 'none';
                document.getElementById('settingsCategories').style.display = 'grid';
            }
        }
        
        function displaySettings() {
            const categories = [
                {
                    key: 'household_size',
                    icon: 'üë•',
                    title: 'Household Size',
                    getValue: () => currentUserSettings.household_size || '1-2 people'
                },
                {
                    key: 'meal_timing',
                    icon: 'üç¥',
                    title: 'Meal Preferences',
                    getValue: () => {
                        const timing = currentUserSettings.meal_timing;
                        if (Array.isArray(timing)) return timing.join(', ');
                        return timing || 'Dinner';
                    }
                },
                {
                    key: 'cooking_methods',
                    icon: 'üë®‚Äçüç≥',
                    title: 'Cooking Style',
                    getValue: () => {
                        const methods = currentUserSettings.cooking_methods || [];
                        return methods.length ? `${methods.length} preferences` : 'Not set';
                    }
                },
                {
                    key: 'dietary_restrictions',
                    icon: 'ü•ó',
                    title: 'Dietary Restrictions',
                    getValue: () => {
                        const restrictions = currentUserSettings.dietary_restrictions || [];
                        return restrictions.length ? restrictions.join(', ') : 'None';
                    }
                },
                {
                    key: 'goals',
                    icon: 'üéØ',
                    title: 'Health Goals',
                    getValue: () => {
                        const goals = currentUserSettings.goals || [];
                        return goals.length ? goals.join(', ') : 'Not set';
                    }
                }
            ];
            
            const html = categories.map(cat => `
                <div class="category-card" style="background: white; border-radius: 12px; padding: 20px; border: 1px solid #e9ecef; transition: all 0.2s ease;">
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span style="font-size: 24px;">${cat.icon}</span>
                            <div>
                                <div style="font-size: 18px; font-weight: 600;">${cat.title}</div>
                                <div style="color: #6c757d; font-size: 14px;">${cat.getValue()}</div>
                            </div>
                        </div>
                        <span style="color: #adb5bd; font-size: 20px;">‚Ä∫</span>
                    </div>
                </div>
            `).join('');
            
            document.getElementById('settingsCategories').innerHTML = html;
        }

        // Sync Meals From Cart Tab Functions
        async function syncMealsFromCart() {
            console.log('üîÑ Syncing meals from Cart tab to Meals tab');

            // Fetch meals from Redis (single source of truth)
            try {
                const phone = getPhoneNumber();
                if (!phone) {
                    console.log('‚ùå No phone number available for meal sync');
                    showEmptyMealState();
                    return;
                }

                const response = await fetch(`/api/get-saved-cart?force_refresh=false`);
                if (response.ok) {
                    const data = await response.json();

                    // Comprehensive logging
                    console.log('üì• API Response:', {
                        url: '/api/get-saved-cart',
                        hasSuccess: 'success' in data,
                        hasMeals: !!data.meals,
                        mealCount: data.meals?.length || 0,
                        hasCart: !!data.cart_data,
                        cacheType: data.cache_type
                    });

                    if (data.meals && data.meals.length > 0) {
                        console.log('‚úÖ Found meals from Redis cache:', data.meals.length, 'meals');
                        renderMealSuggestions(data.meals);
                        // Sync lock status from Redis
                        FarmDashboard.MealLocking.syncFromRedis();
                        return;
                    } else {
                        console.log('‚ö†Ô∏è No cached meals found in Redis response');
                    }
                } else {
                    console.log('‚ùå Failed to fetch cached meals from API');
                }
            } catch (e) {
                console.log('‚ùå Error fetching meals from Redis:', e);
            }

            // If no meals but cart exists, trigger generation
            const phone = getPhoneNumber();
            if (phone) {
                console.log('üîÑ No meals found - generating from cart...');
                try {
                    const genResponse = await fetch('/api/refresh-meals', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ phone: phone })
                    });

                    if (genResponse.ok) {
                        const genData = await genResponse.json();
                        if (genData.success && genData.meals) {
                            console.log('‚úÖ Generated', genData.meals.length, 'new meals');
                            renderMealSuggestions(genData.meals);
                            return;
                        }
                    }
                } catch (e) {
                    console.error('‚ùå Failed to generate meals:', e);
                }
            }

            // Fall back to trying to extract from Cart tab DOM
            const mealSuggestionsContainer = document.getElementById('mealSuggestionsContainer');
            if (mealSuggestionsContainer && mealSuggestionsContainer.children.length > 0) {
                console.log('‚úÖ Found meal suggestions in Cart tab DOM');
                // Extract meal data from first card
                const firstMealCard = mealSuggestionsContainer.children[0];
                const mealName = firstMealCard.querySelector('.meal-name')?.textContent;
                const mealMeta = firstMealCard.querySelector('.meal-meta')?.textContent;

                if (mealName && mealMeta) {
                    // Parse meta info (e.g., "25 mins ‚Ä¢ 32g protein ‚Ä¢ Dinner")
                    const metaParts = mealMeta.split(' ‚Ä¢ ');
                    const meal = {
                        name: mealName,
                        time: metaParts[0] || '30 mins',
                        protein: metaParts[1] || '25g protein',
                        type: metaParts[2] || 'Dinner'
                    };
                    populateSimpleMealCard(meal);
                    return;
                }
            }

            // If no meals found, show empty state
            console.log('‚ùå No meal suggestions found - showing empty state');
            showEmptyMealState();
        }

        function populateSimpleMealCard(meal) {
            console.log('üçΩÔ∏è Populating enhanced Meals tab with assembly instructions:', meal);

            // Check if all required elements exist
            const mealTitle = document.getElementById('mealTitle');
            const mealTime = document.getElementById('mealTime');
            const ingredientsList = document.getElementById('simpleMealIngredients');
            const simpleMealCard = document.getElementById('simpleMealCard');

            if (!mealTitle || !mealTime || !ingredientsList || !simpleMealCard) {
                console.log('‚ùå Meal card elements not found');
                return;
            }

            // Enhanced meal title with protein prominently displayed
            const proteinText = meal.protein ? ` ‚Ä¢ ${meal.protein}g protein` : '';
            mealTitle.innerHTML = `
                <div style="font-size: 18px; font-weight: 600; color: #2d3748; margin-bottom: 4px;">
                    ${meal.name}
                </div>
                <div style="font-size: 14px; color: #4169E1; font-weight: 500;">
                    ${meal.time}${proteinText} ‚Ä¢ ${meal.servings || 2} servings
                </div>
            `;

            // Generate assembly steps based on meal type
            const assemblySteps = generateAssemblySteps(meal);

            // Show enhanced content with assembly instructions
            ingredientsList.innerHTML = `
                <div style="margin-bottom: 16px;">
                    <div style="font-size: 14px; font-weight: 600; color: #2d3748; margin-bottom: 8px;">
                        üî• Quick Assembly (15 minutes)
                    </div>
                    <div style="background: #f7fafc; border-radius: 8px; padding: 12px;">
                        ${assemblySteps.map((step, index) => `
                            <div style="display: flex; align-items: flex-start; margin-bottom: ${index < assemblySteps.length - 1 ? '8px' : '0'};">
                                <div style="background: #4169E1; color: white; border-radius: 50%; width: 18px; height: 18px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 600; margin-right: 8px; flex-shrink: 0; margin-top: 1px;">
                                    ${index + 1}
                                </div>
                                <div style="font-size: 13px; color: #4a5568; line-height: 1.4;">
                                    ${step}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <div style="margin-bottom: 16px;">
                    <div style="font-size: 14px; font-weight: 600; color: #2d3748; margin-bottom: 8px;">
                        üì¶ From Your Cart
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                        ${getKeyIngredients(meal).map(ingredient => `
                            <div style="background: #e6f3ff; color: #2b6cb0; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: 500;">
                                ${ingredient}
                            </div>
                        `).join('')}
                    </div>
                </div>

                <div style="background: #fff5f5; border-left: 3px solid #fed7d7; padding: 8px 12px; border-radius: 4px;">
                    <div style="font-size: 12px; color: #c53030; font-weight: 500;">
                        üí° Storage Tip: ${getStorageTip(meal)}
                    </div>
                </div>
            `;

            // Clear the default mealTime since we moved it to title
            mealTime.textContent = '';

            // Show the card
            showMealCard();

            console.log('‚úÖ Enhanced meal card populated with assembly instructions');
        }

        function generateAssemblySteps(meal) {
            const mealName = meal.name ? meal.name.toLowerCase() : '';

            // Smart assembly steps based on meal type
            if (mealName.includes('sheet-pan') || mealName.includes('sheet pan')) {
                return [
                    "Preheat oven to 425¬∞F and line a sheet pan with parchment",
                    "Season protein with salt, pepper, and olive oil; place on one side",
                    "Toss vegetables with olive oil and arrange around protein; roast 18-22 min"
                ];
            } else if (mealName.includes('skillet') || mealName.includes('stir-fry')) {
                return [
                    "Heat 1 tbsp oil in a large skillet over medium-high heat",
                    "Add protein and cook until browned (4-6 minutes), then remove",
                    "Add vegetables, cook 3-4 minutes, return protein and toss to combine"
                ];
            } else if (mealName.includes('roasted') || mealName.includes('roast')) {
                return [
                    "Preheat oven to 400¬∞F and prep a baking dish with oil",
                    "Season ingredients with herbs, salt, and pepper; arrange in dish",
                    "Roast 25-30 minutes until protein is cooked through and vegetables tender"
                ];
            } else if (mealName.includes('salad') || mealName.includes('bowl')) {
                return [
                    "Wash and chop all fresh vegetables into bite-sized pieces",
                    "Prepare protein (cook if needed) and let cool slightly",
                    "Combine in bowl, add dressing and toss gently to serve"
                ];
            } else {
                // Generic cooking steps
                return [
                    "Prep all ingredients by washing, chopping, and seasoning as needed",
                    "Cook protein first until done, then set aside while preparing vegetables",
                    "Combine everything in final cooking step, adjust seasoning and serve hot"
                ];
            }
        }

        function getKeyIngredients(meal) {
            // Extract likely ingredients from meal name
            const mealName = meal.name ? meal.name.toLowerCase() : '';
            const ingredients = [];

            // Common proteins
            if (mealName.includes('chicken')) ingredients.push('Chicken');
            if (mealName.includes('salmon')) ingredients.push('Salmon');
            if (mealName.includes('turkey')) ingredients.push('Turkey');

            // Common vegetables
            if (mealName.includes('zucchini')) ingredients.push('Zucchini');
            if (mealName.includes('tomato')) ingredients.push('Tomatoes');
            if (mealName.includes('carrot')) ingredients.push('Carrots');
            if (mealName.includes('potato')) ingredients.push('Potatoes');
            if (mealName.includes('onion')) ingredients.push('Onions');
            if (mealName.includes('arugula')) ingredients.push('Arugula');

            // Default if nothing found
            if (ingredients.length === 0) {
                ingredients.push('Protein', 'Vegetables', 'Seasonings');
            }

            return ingredients.slice(0, 4); // Max 4 ingredients to keep clean
        }

        function getStorageTip(meal) {
            const mealName = meal.name ? meal.name.toLowerCase() : '';

            if (mealName.includes('salmon') || mealName.includes('fish')) {
                return "Use fish within 1-2 days for best quality";
            } else if (mealName.includes('chicken') || mealName.includes('turkey')) {
                return "Poultry keeps 3-4 days refrigerated";
            } else if (mealName.includes('salad')) {
                return "Keep greens crisp - store washed and dried";
            } else {
                return "Most vegetables keep 5-7 days in refrigerator";
            }
        }

        // populateMealLockingGrid function - DELETED to eliminate competing views
        // This function was creating unwanted blue bordered cards with "Unlock" buttons
        // All meal rendering now goes through renderMealSuggestions() for consistency

        // toggleMealLock function - DELETED to eliminate competing views

        function regenerateSingleMeal(mealIndex) {
            console.log('üîÑ Regenerating meal', mealIndex);
            // TODO: Implement single meal regeneration
            alert('Single meal regeneration coming soon!');
        }

        function showEmptyMealState() {
            console.log('üì≠ Showing empty meal state');
            const mealTitle = document.getElementById('mealTitle');
            const mealTime = document.getElementById('mealTime');
            const ingredientsList = document.getElementById('simpleMealIngredients');

            if (mealTitle) mealTitle.textContent = 'üçΩÔ∏è Suggested Meal';
            if (mealTime) mealTime.textContent = 'Analyze cart first';
            if (ingredientsList) ingredientsList.innerHTML = '<div class="ingredient-tag">No meal suggestions yet</div>';
        }

        // Debouncing helper function to prevent multiple API calls
        function debounceMealGeneration(func, timeout = MEAL_DEBOUNCE_TIMEOUT) {
            return function(...args) {
                const now = Date.now();

                // Check if generation is already in progress
                if (mealGenerationInProgress) {
                    console.log('‚è∏Ô∏è [DEBOUNCE] Meal generation already in progress - ignoring request');
                    return;
                }

                // Check time-based debouncing
                if (now - lastMealGenerationTime < MEAL_DEBOUNCE_TIMEOUT) {
                    console.log(`‚è∏Ô∏è [DEBOUNCE] Too soon since last generation (${now - lastMealGenerationTime}ms < ${MEAL_DEBOUNCE_TIMEOUT}ms) - ignoring request`);
                    return;
                }

                // Clear any existing timeout
                if (mealGenerationTimeoutId) {
                    clearTimeout(mealGenerationTimeoutId);
                }

                // Set up new timeout
                mealGenerationTimeoutId = setTimeout(async () => {
                    mealGenerationInProgress = true;
                    lastMealGenerationTime = Date.now();

                    try {
                        await func.apply(this, args);
                    } finally {
                        mealGenerationInProgress = false;
                    }
                }, timeout);
            };
        }

        async function regenerateSimpleMealInternal() {
            const timestamp = new Date().toISOString();
            console.log(`üîÑ [${timestamp}] Regenerating simple meal using Cart tab API...`);

            const button = document.getElementById('regenerateMeal');
            if (!button) {
                console.log('‚ùå Regenerate button not found');
                return;
            }

            const originalText = button.textContent;
            button.textContent = 'Generating...';
            button.disabled = true;

            try {
                // Use the same API endpoint that Cart tab uses
                const storedData = localStorage.getItem('cartAnalysisData');
                if (!storedData) {
                    throw new Error('No cart data available - analyze cart first');
                }

                const { cartData } = JSON.parse(storedData);
                const phone = localStorage.getItem('userPhone');

                console.log(`üìä [MEAL DEBUG] Request data:`, {
                    timestamp,
                    phone: phone,
                    hasCartData: !!cartData,
                    customizableBoxes: cartData?.customizable_boxes?.length || 0,
                    nonCustomizableBoxes: cartData?.non_customizable_boxes?.length || 0,
                    individualItems: cartData?.individual_items?.length || 0
                });

                console.log('üçΩÔ∏è Calling same API as Cart tab for meal suggestions...');
                const apiRequestStart = Date.now();
                const response = await fetch('/api/refresh-meals', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        cart_data: cartData,
                        phone: phone
                    })
                });

                const apiRequestTime = Date.now() - apiRequestStart;
                console.log(`‚è±Ô∏è [MEAL DEBUG] API request took: ${apiRequestTime}ms`);

                const data = await response.json();
                console.log(`üì• [MEAL DEBUG] API Response:`, {
                    success: data.success,
                    mealsCount: data.meals?.length || 0,
                    hasError: !!data.error,
                    responseTime: apiRequestTime + 'ms',
                    rawData: data
                });

                if (data.success && data.meals && data.meals.length > 0) {
                    console.log('‚úÖ Got new meal suggestion:', data.meals[0]);

                    // Meals updated (no localStorage caching)

                    // Update Meals tab display with first meal
                    populateSimpleMealCard(data.meals[0]);

                    // Also update Cart tab if it exists
                    if (typeof updateMealSuggestions === 'function') {
                        updateMealSuggestions(data.meals);
                    }
                } else {
                    throw new Error(data.error || 'Failed to generate new meal');
                }

            } catch (error) {
                console.error('‚ùå Error regenerating meal:', error);
                alert('Failed to generate new meal. Please try again.');
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        // Create debounced version of the meal generation function
        const regenerateSimpleMeal = debounceMealGeneration(regenerateSimpleMealInternal);

        // ===== MEAL LOCKING FUNCTIONALITY =====

        let lockedMeals = []; // Array to store locked meals
        let currentMealSuggestions = []; // Current meal suggestions from API

        // Generate meal suggestions for the new interface
        async function generateMealSuggestions() {
            console.log('üîÑ Generating meal suggestions for locking interface...');

            const button = document.getElementById('generateMealsButton');
            if (!button) return;

            const originalText = button.textContent;
            button.textContent = '‚è≥ Generating...';
            button.disabled = true;

            try {
                const storedData = localStorage.getItem('cartAnalysisData');
                if (!storedData) {
                    throw new Error('No cart data available - analyze cart first');
                }

                const { cartData } = JSON.parse(storedData);
                const phone = localStorage.getItem('userPhone');

                console.log('üçΩÔ∏è [MEAL LOCK DEBUG] Generating 4 meals for locking interface...');
                const response = await fetch('/api/refresh-meals', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        cart_data: cartData,
                        phone: phone
                    })
                });

                const data = await response.json();

                if (data.success && data.meals && data.meals.length > 0) {
                    currentMealSuggestions = data.meals;
                    console.log(`‚úÖ Got ${data.meals.length} meal suggestions`);
                    renderMealSuggestions(data.meals);

                    // Meals updated (no localStorage caching)
                } else {
                    throw new Error(data.error || 'Failed to generate meal suggestions');
                }

            } catch (error) {
                console.error('‚ùå Error generating meal suggestions:', error);
                // Removed intrusive alert - errors are logged and handled gracefully
            } finally {
                button.textContent = originalText;
                button.disabled = false;
                // Reset button styling to prevent stuck highlighting
                button.style.background = '#faf8f2';
                button.style.color = '#07261e';
            }
        }

        // Render meal suggestions in the grid
        function renderMealSuggestions(meals) {
            console.log('üé® Rendering meal suggestions with', meals.length, 'meals');

            // Try to find existing grid
            let grid = document.getElementById('mealSuggestionsGrid');

            // If not found, create it dynamically (for Meals tab)
            if (!grid) {
                console.log('‚ö†Ô∏è mealSuggestionsGrid not found - creating dynamically');
                const container = document.getElementById('simpleMealCardContainer');
                if (container) {
                    // Clear any existing loading state
                    const loadingState = container.querySelector('.meal-loading-state');
                    if (loadingState) {
                        loadingState.remove();
                        console.log('üßπ Cleared loading state');
                    }

                    // Create the grid dynamically
                    grid = document.createElement('div');
                    grid.id = 'mealSuggestionsGrid';
                    grid.className = 'meal-suggestions-grid';
                    container.appendChild(grid);
                    console.log('‚úÖ Created mealSuggestionsGrid dynamically in Meals tab');
                } else {
                    console.error('‚ùå simpleMealCardContainer not found - cannot create grid');
                    return;
                }
            }

            // Make sure the parent container is visible
            const container = document.getElementById('simpleMealCardContainer');
            if (container) {
                container.style.display = 'block';
            }

            grid.innerHTML = '';

            meals.forEach((meal, index) => {
                const card = createMealSuggestionCard(meal, index);
                grid.appendChild(card);
            });

            // Update summary bar with actual meal data
            updateSummaryBar(meals);
        }

        // Update the weekly summary bar with calculated stats
        function updateSummaryBar(meals) {
            const summaryBar = document.getElementById('weeklySummaryBar');
            if (!summaryBar || !meals || meals.length === 0) {
                if (summaryBar) summaryBar.style.display = 'none';
                return;
            }

            // Calculate stats
            const mealCount = meals.length;
            const totalProtein = meals.reduce((sum, meal) => {
                try {
                    // Handle various protein data formats
                    let proteinValue = 0;
                    if (typeof meal.protein === 'number') {
                        proteinValue = meal.protein;
                    } else if (typeof meal.protein === 'object' && meal.protein && meal.protein.value) {
                        proteinValue = meal.protein.value;
                    } else if (meal.protein) {
                        const proteinStr = String(meal.protein);
                        const proteinMatch = proteinStr.match(/(\d+)/);
                        proteinValue = proteinMatch ? parseInt(proteinMatch[1]) : 0;
                    }
                    return sum + proteinValue;
                } catch (e) {
                    console.warn('Error parsing protein for meal:', meal, e);
                    return sum;
                }
            }, 0);
            const avgTime = Math.round(meals.reduce((sum, meal) => {
                try {
                    let timeValue = 0;
                    if (typeof meal.time === 'number') {
                        timeValue = meal.time;
                    } else if (meal.time) {
                        const timeStr = String(meal.time);
                        const timeMatch = timeStr.match(/(\d+)/);
                        timeValue = timeMatch ? parseInt(timeMatch[1]) : 0;
                    }
                    return sum + timeValue;
                } catch (e) {
                    console.warn('Error parsing time for meal:', meal, e);
                    return sum;
                }
            }, 0) / meals.length);

            // Update display
            document.getElementById('summaryMealCount').textContent = `${mealCount} meals`;
            document.getElementById('summaryProtein').textContent = `${totalProtein}g protein`;
            document.getElementById('summaryTime').textContent = `Avg ${avgTime} min`;

            // Show the summary bar
            summaryBar.style.display = 'block';
        }

        // Create a meal suggestion card
        function createMealSuggestionCard(meal, index) {
            const card = document.createElement('div');
            card.className = 'meal-suggestion-card';
            card.dataset.mealIndex = index;

            // Check lock status using existing MealLocking system
            const isLocked = FarmDashboard.MealLocking && FarmDashboard.MealLocking.state
                ? FarmDashboard.MealLocking.state.locked[index] || false
                : false;

            // Determine meal type for badge
            const isSnack = meal.type === 'snack';
            const typeLabel = isSnack ? 'üçø Snack' : 'ü•ò Meal';

            card.innerHTML = `
                <div class="meal-card-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                    <div class="meal-card-title" style="font-size: 15px; font-weight: 600; line-height: 1.3; flex: 1; margin-right: 8px;">${meal.name}</div>
                    <button onclick="FarmDashboard.MealLocking.toggleLock(${index})" style="background: none; border: none; cursor: pointer; font-size: 16px; padding: 2px; opacity: 0.7; transition: opacity 0.2s;" title="${isLocked ? 'Unlock meal' : 'Lock meal'}">
                        ${isLocked ? 'üîí' : 'üîì'}
                    </button>
                </div>
                <div class="meal-card-meta" style="margin-bottom: 10px; font-size: 13px; color: #6b7280; line-height: 1.2;">
                    ${meal.time} ‚Ä¢ ${meal.protein} ‚Ä¢ ${typeLabel}
                </div>
                <div class="meal-card-actions">
                    <button onclick="regenerateSimpleMeal()" style="width: 100%; background: #faf8f2; border: 1px solid #e6d8b5; border-radius: 6px; padding: 6px; font-size: 13px; font-weight: 500; color: #07261e; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f3a208'; this.style.color='#07261e'" onmouseout="this.style.background='#faf8f2'; this.style.color='#07261e'">
                        üîÑ Regenerate
                    </button>
                </div>
            `;

            return card;
        }

        // Old lockMeal function - DELETED to eliminate competing views

        // Old unlockMeal function - DELETED to eliminate competing views

        // Old renderLockedMeals function - DELETED to eliminate competing views

        // Old createLockedMealCard function - DELETED to eliminate competing views

        // Old updateLockedMealCount function - DELETED to eliminate competing views

        // Old showLockedMealsSection function - DELETED to eliminate competing views

        // Old hideLockedMealsSectionIfEmpty function - DELETED to eliminate competing views

        // Old clearAllLockedMeals function - DELETED to eliminate competing views

        // Old initializeMealLockingInterface function - DELETED to eliminate competing views
        // This was triggering multiple meal rendering systems simultaneously
        // All meal initialization now handled by syncMealsFromCart()

        function showMealLoadingState() {
            const container = document.getElementById('simpleMealCardContainer');
            if (container) {
                // Check if grid exists, create if not
                let grid = container.querySelector('#mealSuggestionsGrid');
                if (!grid) {
                    grid = document.createElement('div');
                    grid.id = 'mealSuggestionsGrid';
                    grid.className = 'meal-suggestions-grid';
                    container.appendChild(grid);
                    console.log('‚úÖ Created mealSuggestionsGrid for loading state');
                }

                // Show loading in the grid, preserving container structure
                grid.innerHTML = `
                    <div class="meal-loading-state" style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p style="color: #666;">Loading your meal suggestions...</p>
                    </div>
                `;
                console.log('üîÑ Showing loading state in grid (preserving container)');
            }
        }

        // ===== DEBUG HELPER FOR STATE INSPECTION =====

        // Debug helper for state inspection (callable from console)
        window.debugStateInfo = function() {
            const info = {
                timestamp: new Date().toISOString(),
                localStorage: {
                    userPhone: localStorage.getItem('userPhone'),
                    cachedMealSuggestions: localStorage.getItem('cachedMealSuggestions') ?
                        JSON.parse(localStorage.getItem('cachedMealSuggestions')).length + ' meals' : 'none',
                    cachedMealSuggestionsTimestamp: localStorage.getItem('cachedMealSuggestionsTimestamp'),
                    cartAnalysisData: localStorage.getItem('cartAnalysisData') ? 'present' : 'none',
                    cartAnalysisState: localStorage.getItem('cartAnalysisState')
                },
                globalVariables: {
                    mealPlanData: window.mealPlanData ? 'loaded' : 'not loaded',
                    currentState: window.currentState,
                    isAnalyzing: window.isAnalyzing,
                    refreshesLeft: window.refreshesLeft
                },
                cartInfo: window.mealPlanData?.cart_data ? {
                    deliveryDate: window.mealPlanData.cart_data.delivery_date,
                    scrapedTimestamp: window.mealPlanData.cart_data.scraped_timestamp,
                    customizableBoxes: window.mealPlanData.cart_data.customizable_boxes?.length || 0,
                    individualItems: window.mealPlanData.cart_data.individual_items?.length || 0
                } : 'no cart data loaded'
            };

            console.log('üìä STATE DEBUG INFO');
            console.log('===================');
            console.log('üïê Timestamp:', info.timestamp);
            console.log('üíæ localStorage:');
            console.table(info.localStorage);
            console.log('üåê Global Variables:');
            console.table(info.globalVariables);
            if (info.cartInfo !== 'no cart data loaded') {
                console.log('üõí Cart Info:');
                console.table(info.cartInfo);
            } else {
                console.log('üõí Cart Info: No cart data loaded');
            }

            return info;
        };

        console.log('üí° Debug Helper Available: Type debugStateInfo() in console for state inspection');

        // ===== INITIALIZE FARM DASHBOARD =====
        // Initialize organized dashboard structure with meal locking capability
        console.log('üöÄ Initializing organized FarmDashboard...');

        // Initialize all modules
        try {
            FarmDashboard.init();
            console.log('‚úÖ FarmDashboard initialized successfully');
        } catch (error) {
            console.error('‚ùå FarmDashboard initialization failed:', error);
            // Fall back to legacy behavior if initialization fails
        }

        // Make FarmDashboard available globally for debugging
        window.FarmDashboard = FarmDashboard;
        console.log('üîç FarmDashboard available globally for debugging');

    </script>

</body>
</html>