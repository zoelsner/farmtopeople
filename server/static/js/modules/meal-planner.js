/**
 * Meal Planner Module
 * Handles meal calendar, drag-and-drop, and ingredient tracking
 */

import { eventBus, apiCall, saveToStorage, getFromStorage, getPhoneNumber, getMonday, formatDate } from './shared.js';
import { ingredientAllocator } from './ingredient-allocator.js';
import { ingredientCleaner } from './ingredient-cleaner.js';
import { mealGeneratorAPI } from './meal-generator-api.js';

class MealPlanner {
    constructor() {
        this.currentWeek = getMonday(new Date());
        this.mealPlan = null;
        this.ingredientPool = {};
        this.draggedMeal = null;
        this.init();
    }

    init() {
        // Listen for cart analysis completion
        eventBus.on('cart-analyzed', (cartData) => {
            this.initializeMealPlan(cartData);
        });
    }

    /**
     * Initialize meal plan from cart data
     */
    initializeMealPlan(cartData) {
        if (!cartData) return;
        
        // Build ingredient pool from cart
        this.ingredientPool = this.buildIngredientPool(cartData);
        
        // Create initial meal plan structure
        this.mealPlan = {
            week_of: this.currentWeek.toISOString(),
            ingredient_pool: this.ingredientPool,
            meals: {}
        };
        
        // Render the calendar
        this.showCalendar();
        
        // Generate initial meals
        this.generateInitialMeals();
    }

    /**
     * Build ingredient pool from cart data
     */
    buildIngredientPool(cartData) {
        const pool = {};
        
        // Process individual items
        if (cartData.individual_items) {
            cartData.individual_items.forEach(item => {
                pool[item.name] = {
                    total: item.quantity || 1,
                    allocated: 0,
                    remaining: item.quantity || 1,
                    unit: item.unit || 'piece'
                };
            });
        }
        
        // Process box items
        ['customizable_boxes', 'non_customizable_boxes'].forEach(boxType => {
            if (cartData[boxType]) {
                cartData[boxType].forEach(box => {
                    if (box.selected_items) {
                        box.selected_items.forEach(item => {
                            if (pool[item.name]) {
                                pool[item.name].total += (item.quantity || 1);
                                pool[item.name].remaining += (item.quantity || 1);
                            } else {
                                pool[item.name] = {
                                    total: item.quantity || 1,
                                    allocated: 0,
                                    remaining: item.quantity || 1,
                                    unit: item.unit || 'piece'
                                };
                            }
                        });
                    }
                });
            }
        });
        
        return pool;
    }

    /**
     * Generate initial meal suggestions using ChatGPT API
     */
    async generateInitialMeals() {
        // Show loading state
        this.showMealGenerationLoading();
        
        try {
            // Get user preferences
            const userData = getFromStorage('userData');
            const preferences = userData?.preferences || {};
            
            // Generate meals via API (this will use ChatGPT)
            const meals = await mealGeneratorAPI.generateMealPlan(
                this.ingredientPool, 
                preferences
            );
            
            if (meals && meals.length > 0) {
                // Process and display the AI-generated meals
                this.processChatGPTMeals(meals);
            } else {
                // Fallback to template generation
                console.log('API generation failed, using fallback');
                this.generateSampleMeals();
            }
        } catch (error) {
            console.error('Failed to generate meals:', error);
            this.generateSampleMeals();
        } finally {
            this.hideMealGenerationLoading();
        }
    }
    
    /**
     * Process meals generated by ChatGPT
     */
    processChatGPTMeals(meals) {
        // Clear existing meals
        this.mealPlan.meals = {};
        
        meals.forEach(meal => {
            // Allocate ingredients based on what ChatGPT suggested
            const allocated = [];
            
            if (meal.ingredients_used) {
                meal.ingredients_used.forEach(ing => {
                    // Find in pool and allocate
                    const poolItem = this.findInPool(ing.name);
                    if (poolItem) {
                        const amount = ing.amount || 1;
                        poolItem.allocated = (poolItem.allocated || 0) + amount;
                        poolItem.remaining = Math.max(0, poolItem.total - poolItem.allocated);
                        
                        allocated.push({
                            name: poolItem.name,
                            amount: amount,
                            unit: ing.unit || poolItem.unit
                        });
                    }
                });
            }
            
            // Store the meal
            this.mealPlan.meals[meal.day] = {
                id: `meal-${meal.day}-${Date.now()}`,
                meal_data: {
                    name: meal.name,
                    protein: meal.protein,
                    cook_time: meal.cook_time,
                    servings: meal.servings
                },
                allocated_ingredients: allocated
            };
            
            // Render the meal card
            this.renderMealCard(meal.day, this.mealPlan.meals[meal.day]);
        });
        
        // Update ingredient pool display
        this.updateIngredientPool();
        
        // Save the meal plan
        this.saveMealPlan();
    }
    
    /**
     * Find ingredient in pool (fuzzy match)
     */
    findInPool(ingredientName) {
        const searchName = ingredientName.toLowerCase();
        
        for (const [name, data] of Object.entries(this.ingredientPool)) {
            const poolName = name.toLowerCase();
            // Check if names are similar
            if (poolName.includes(searchName) || searchName.includes(poolName)) {
                return { name, ...data };
            }
        }
        return null;
    }
    
    /**
     * Show loading state while generating meals
     */
    showMealGenerationLoading() {
        // Add loading spinner to each day
        const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
        days.forEach(day => {
            const mealSlot = document.querySelector(`[data-day="${day}"] .meal-slot`);
            if (mealSlot) {
                mealSlot.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <div class="loading-animation" style="width: 30px; height: 30px; margin: 0 auto;"></div>
                        <div style="color: #6c757d; font-size: 12px; margin-top: 8px;">Generating meal...</div>
                    </div>
                `;
            }
        });
    }
    
    /**
     * Hide loading state
     */
    hideMealGenerationLoading() {
        // Will be replaced by actual meal cards or empty state
    }

    /**
     * Generate sample meals based on actual cart contents
     */
    generateSampleMeals() {
        const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
        
        // Look at what proteins we have
        const proteins = this.identifyProteins();
        const vegetables = this.identifyVegetables();
        
        // Generate meals based on what's available
        const mealTemplates = this.generateMealTemplates(proteins, vegetables);
        
        days.forEach((day, index) => {
            if (index < mealTemplates.length) {
                const meal = mealTemplates[index];
                const ingredients = this.allocateIngredientsForMeal(meal);
                
                this.mealPlan.meals[day] = {
                    id: `meal-${day}-${Date.now()}`,
                    meal_data: meal,
                    allocated_ingredients: ingredients
                };
                
                this.renderMealCard(day, this.mealPlan.meals[day]);
            }
        });
        
        this.updateIngredientPool();
    }
    
    /**
     * Identify available proteins in the pool
     */
    identifyProteins() {
        const proteins = [];
        
        Object.entries(this.ingredientPool).forEach(([name, info]) => {
            const nameLower = name.toLowerCase();
            
            if (nameLower.includes('chicken')) {
                proteins.push({ name, type: 'chicken', amount: info.total });
            } else if (nameLower.includes('beef') || nameLower.includes('steak')) {
                proteins.push({ name, type: 'beef', amount: info.total });
            } else if (nameLower.includes('fish') || nameLower.includes('salmon')) {
                proteins.push({ name, type: 'fish', amount: info.total });
            } else if (nameLower.includes('egg')) {
                proteins.push({ name, type: 'eggs', amount: info.total });
            }
        });
        
        return proteins;
    }
    
    /**
     * Identify available vegetables in the pool
     */
    identifyVegetables() {
        const vegetables = [];
        
        Object.entries(this.ingredientPool).forEach(([name, info]) => {
            const nameLower = name.toLowerCase();
            
            // Skip proteins
            if (nameLower.includes('chicken') || nameLower.includes('beef') || 
                nameLower.includes('fish') || nameLower.includes('egg')) {
                return;
            }
            
            // Skip fruits (for now)
            if (nameLower.includes('apple') || nameLower.includes('peach') || 
                nameLower.includes('plum') || nameLower.includes('nectarine')) {
                return;
            }
            
            vegetables.push({ name, amount: info.total });
        });
        
        return vegetables;
    }
    
    /**
     * Generate meal templates based on available ingredients
     */
    generateMealTemplates(proteins, vegetables) {
        const meals = [];
        
        // Create meals for each protein we have
        proteins.forEach((protein, index) => {
            let mealName;
            let cookTime = '25 min';
            
            // Clean the protein name first
            const cleanProteinName = ingredientCleaner.cleanIngredientName(protein.name);
            
            if (protein.type === 'chicken') {
                const cookingMethods = ['Pan-Seared', 'Grilled', 'Roasted', 'Herb-Crusted', 'Baked'];
                const method = cookingMethods[index % cookingMethods.length];
                
                // Pick some vegetables to pair
                const vegNames = vegetables.slice(0, 2).map(v => 
                    ingredientCleaner.cleanIngredientName(v.name)
                );
                
                mealName = ingredientCleaner.generateCleanMealName(
                    cleanProteinName, 
                    vegNames, 
                    method
                );
            } else if (protein.type === 'beef') {
                mealName = ingredientCleaner.generateCleanMealName(
                    cleanProteinName,
                    ['Seasonal Vegetables'],
                    'Grilled'
                );
                cookTime = '30 min';
            } else if (protein.type === 'fish') {
                mealName = `Pan-Seared ${cleanProteinName} with Lemon`;
                cookTime = '20 min';
            } else if (protein.type === 'eggs') {
                const cornName = vegetables.find(v => v.name.toLowerCase().includes('corn'))?.name || 'Vegetables';
                mealName = `Scrambled ${cleanProteinName} with ${ingredientCleaner.cleanIngredientName(cornName)}`;
                cookTime = '15 min';
            } else {
                mealName = `${cleanProteinName} with Seasonal Vegetables`;
            }
            
            meals.push({
                name: mealName,
                protein: protein.type === 'chicken' ? '25g' : 
                         protein.type === 'beef' ? '28g' : 
                         protein.type === 'fish' ? '22g' : '15g',
                cook_time: cookTime,
                servings: 2
            });
        });
        
        // If we don't have enough meals, add some vegetable-focused ones
        while (meals.length < 5 && vegetables.length > 0) {
            meals.push({
                name: 'Roasted Seasonal Vegetables with Herbs',
                protein: '8g',
                cook_time: '30 min',
                servings: 2
            });
        }
        
        return meals.slice(0, 5); // Return max 5 meals
    }

    /**
     * Allocate ingredients for a meal using smart allocator
     */
    allocateIngredientsForMeal(meal) {
        // Use the smart allocator
        const allocated = ingredientAllocator.allocateForMeal(meal, this.ingredientPool);
        
        // Update the pool with new allocations
        this.ingredientPool = ingredientAllocator.rebalancePool({
            ingredient_pool: this.ingredientPool,
            meals: this.mealPlan.meals
        });
        
        return allocated;
    }

    /**
     * Render a meal card
     */
    renderMealCard(day, meal) {
        const mealSlot = document.querySelector(`[data-day="${day}"] .meal-slot`);
        if (!mealSlot) return;
        
        const mealData = meal.meal_data || {};
        const ingredients = meal.allocated_ingredients || [];
        
        const ingredientChips = ingredients.slice(0, 3).map(ing => 
            `<span class="ingredient-chip">${ing.name}</span>`
        ).join('');
        
        mealSlot.innerHTML = `
            <div class="meal-card" draggable="true" data-meal-id="${meal.id}" data-day="${day}">
                <div class="meal-header">
                    <div class="meal-name">${mealData.name || 'Unnamed Meal'}</div>
                    <span class="protein-badge">${mealData.protein || '30g'} protein</span>
                </div>
                <div class="meal-details">
                    <span>⏱️ ${mealData.cook_time || '30 min'} • 👥 ${mealData.servings || 2} servings</span>
                </div>
                <div class="ingredients-used">
                    ${ingredientChips}
                    ${ingredients.length > 3 ? `<span class="ingredient-chip">+${ingredients.length - 3} more</span>` : ''}
                </div>
                <div class="meal-actions">
                    <button class="meal-action-btn" onclick="MealPlanner.regenerateMeal('${day}')" title="Regenerate meal">🔄</button>
                    <button class="meal-action-btn" onclick="MealPlanner.lockMeal('${day}')" title="Lock & generate recipe">🔒</button>
                    <button class="meal-action-btn" onclick="MealPlanner.removeMeal('${day}')" title="Remove meal">❌</button>
                </div>
            </div>
        `;
        
        // Setup drag handlers
        this.setupMealDragHandlers(mealSlot.querySelector('.meal-card'));
    }

    /**
     * Update ingredient pool display with proper formatting
     */
    updateIngredientPool() {
        const container = document.getElementById('ingredientList');
        if (!container) return;
        
        // Get all ingredients and sort by usage
        const sortedIngredients = Object.entries(this.ingredientPool)
            .map(([name, info]) => ({
                name,
                ...info,
                usagePercent: ingredientAllocator.calculateUsagePercentage(info)
            }))
            .sort((a, b) => b.usagePercent - a.usagePercent)
            .slice(0, 12); // Show top 12 ingredients
        
        const ingredientHTML = sortedIngredients.map(ingredient => {
            const usedPercent = ingredient.usagePercent;
            const remaining = ingredientAllocator.formatRemaining(ingredient);
            const status = usedPercent < 30 ? 'low' : usedPercent < 70 ? 'medium' : 'high';
            // Clean name for display but keep some detail
            const displayName = ingredientCleaner.cleanForIngredientPool(ingredient.name);
            
            return `
                <div class="ingredient-item">
                    <div class="ingredient-name">${displayName}</div>
                    <div class="ingredient-progress">
                        <div class="ingredient-progress-bar ${status}" style="width: ${usedPercent}%"></div>
                    </div>
                    <div class="ingredient-status">
                        <span>${remaining} left</span>
                        <span>${usedPercent}% used</span>
                    </div>
                </div>
            `;
        }).join('');
        
        container.innerHTML = ingredientHTML;
    }

    /**
     * Setup drag and drop handlers
     */
    setupMealDragHandlers(element) {
        if (!element) return;
        
        element.addEventListener('dragstart', (e) => {
            this.draggedMeal = {
                element: e.target,
                day: e.target.dataset.day,
                mealId: e.target.dataset.mealId
            };
            e.target.classList.add('dragging');
        });
        
        element.addEventListener('dragend', (e) => {
            e.target.classList.remove('dragging');
            this.draggedMeal = null;
        });
    }

    /**
     * Setup drop zones for days
     */
    setupDropZones() {
        document.querySelectorAll('.meal-slot').forEach(slot => {
            slot.addEventListener('dragover', (e) => {
                e.preventDefault();
                slot.classList.add('drag-over');
            });
            
            slot.addEventListener('dragleave', () => {
                slot.classList.remove('drag-over');
            });
            
            slot.addEventListener('drop', (e) => {
                e.preventDefault();
                slot.classList.remove('drag-over');
                
                if (this.draggedMeal) {
                    const newDay = slot.closest('[data-day]').dataset.day;
                    this.moveMeal(this.draggedMeal.day, newDay);
                }
            });
        });
    }

    /**
     * Move meal between days
     */
    moveMeal(fromDay, toDay) {
        if (fromDay === toDay) return;
        
        const meal = this.mealPlan.meals[fromDay];
        if (!meal) return;
        
        // Check if target day already has a meal
        if (this.mealPlan.meals[toDay]) {
            // Swap meals
            const tempMeal = this.mealPlan.meals[toDay];
            this.mealPlan.meals[toDay] = meal;
            this.mealPlan.meals[fromDay] = tempMeal;
            
            this.renderMealCard(fromDay, tempMeal);
            this.renderMealCard(toDay, meal);
        } else {
            // Move meal
            this.mealPlan.meals[toDay] = meal;
            delete this.mealPlan.meals[fromDay];
            
            this.clearMealSlot(fromDay);
            this.renderMealCard(toDay, meal);
        }
        
        // Save state
        this.saveMealPlan();
    }

    /**
     * Regenerate meal for a specific day
     */
    async regenerateMeal(day) {
        const phone = getPhoneNumber();
        if (!phone) return;
        
        // Return ingredients to pool
        const currentMeal = this.mealPlan.meals[day];
        if (currentMeal && currentMeal.allocated_ingredients) {
            currentMeal.allocated_ingredients.forEach(ing => {
                if (this.ingredientPool[ing.name]) {
                    this.ingredientPool[ing.name].allocated -= ing.amount;
                    this.ingredientPool[ing.name].remaining += ing.amount;
                }
            });
        }
        
        try {
            const response = await apiCall('/api/regenerate-meal', {
                method: 'POST',
                body: JSON.stringify({
                    phone_number: phone,
                    day: day,
                    available_ingredients: this.ingredientPool,
                    existing_meals: Object.keys(this.mealPlan.meals)
                        .filter(d => d !== day)
                        .map(d => this.mealPlan.meals[d].meal_data.name)
                })
            });
            
            if (response.meal) {
                const ingredients = this.allocateIngredientsForMeal(response.meal);
                
                this.mealPlan.meals[day] = {
                    id: `meal-${day}-${Date.now()}`,
                    meal_data: response.meal,
                    allocated_ingredients: ingredients
                };
                
                this.renderMealCard(day, this.mealPlan.meals[day]);
                this.updateIngredientPool();
                this.saveMealPlan();
            }
        } catch (error) {
            console.error('Failed to regenerate meal:', error);
            // Fallback to sample meal
            this.generateSampleMealForDay(day);
        }
    }

    /**
     * Lock meal and generate full recipe
     */
    async lockMeal(day) {
        const meal = this.mealPlan.meals[day];
        if (!meal) return;
        
        const phone = getPhoneNumber();
        if (!phone) return;
        
        try {
            const response = await apiCall('/api/generate-recipe', {
                method: 'POST',
                body: JSON.stringify({
                    phone_number: phone,
                    meal: meal.meal_data,
                    ingredients: meal.allocated_ingredients
                })
            });
            
            if (response.recipe_url) {
                // Open recipe in new tab
                window.open(response.recipe_url, '_blank');
            }
        } catch (error) {
            console.error('Failed to generate recipe:', error);
            alert('Failed to generate recipe. Please try again.');
        }
    }

    /**
     * Remove meal from day
     */
    removeMeal(day) {
        const meal = this.mealPlan.meals[day];
        if (!meal) return;
        
        // Return ingredients to pool
        if (meal.allocated_ingredients) {
            meal.allocated_ingredients.forEach(ing => {
                if (this.ingredientPool[ing.name]) {
                    this.ingredientPool[ing.name].allocated -= ing.amount;
                    this.ingredientPool[ing.name].remaining += ing.amount;
                }
            });
        }
        
        // Remove meal
        delete this.mealPlan.meals[day];
        this.clearMealSlot(day);
        this.updateIngredientPool();
        this.saveMealPlan();
    }

    /**
     * Clear meal slot
     */
    clearMealSlot(day) {
        const mealSlot = document.querySelector(`[data-day="${day}"] .meal-slot`);
        if (mealSlot) {
            mealSlot.innerHTML = '<div class="empty-meal-slot">+ Add meal</div>';
        }
    }

    /**
     * Update week display
     */
    updateWeekDisplay() {
        const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'];
        
        days.forEach((day, index) => {
            const date = new Date(this.currentWeek);
            date.setDate(date.getDate() + index);
            
            const dateElement = document.getElementById(`${day}-date`);
            if (dateElement) {
                dateElement.textContent = formatDate(date, 'short');
            }
        });
        
        // Update week header
        const weekElement = document.getElementById('currentWeek');
        if (weekElement) {
            const endDate = new Date(this.currentWeek);
            endDate.setDate(endDate.getDate() + 4);
            weekElement.textContent = `${formatDate(this.currentWeek, 'short')} - ${formatDate(endDate, 'short')}`;
        }
    }

    /**
     * Change week
     */
    changeWeek(direction) {
        const newWeek = new Date(this.currentWeek);
        newWeek.setDate(newWeek.getDate() + (direction * 7));
        
        this.currentWeek = newWeek;
        this.updateWeekDisplay();
        
        // Load meal plan for new week
        this.loadMealPlanForWeek();
    }

    /**
     * Show calendar view
     */
    showCalendar() {
        document.getElementById('mealPlanEmpty').style.display = 'none';
        document.getElementById('mealCalendarGrid').style.display = 'grid';
        
        this.updateWeekDisplay();
        this.setupDropZones();
        this.updateIngredientPool();
    }

    /**
     * Save meal plan to storage
     */
    saveMealPlan() {
        if (!this.mealPlan) return;
        
        saveToStorage(`mealPlan_${this.currentWeek.toISOString()}`, this.mealPlan);
    }

    /**
     * Load meal plan for week
     */
    loadMealPlanForWeek() {
        const saved = getFromStorage(`mealPlan_${this.currentWeek.toISOString()}`);
        
        if (saved) {
            this.mealPlan = saved;
            this.ingredientPool = saved.ingredient_pool || {};
            
            // Render all meals
            Object.entries(saved.meals || {}).forEach(([day, meal]) => {
                this.renderMealCard(day, meal);
            });
            
            this.updateIngredientPool();
        } else {
            // Clear calendar for new week
            ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'].forEach(day => {
                this.clearMealSlot(day);
            });
        }
    }

    /**
     * Generate sample meal for specific day (fallback)
     */
    generateSampleMealForDay(day) {
        const sampleMeals = [
            { name: 'Protein Power Bowl', protein: '35g', cook_time: '25 min', servings: 2 },
            { name: 'Garden Fresh Salad', protein: '28g', cook_time: '15 min', servings: 2 },
            { name: 'Hearty Veggie Stir-Fry', protein: '30g', cook_time: '20 min', servings: 3 }
        ];
        
        const meal = sampleMeals[Math.floor(Math.random() * sampleMeals.length)];
        const ingredients = this.allocateIngredientsForMeal(meal);
        
        this.mealPlan.meals[day] = {
            id: `meal-${day}-${Date.now()}`,
            meal_data: meal,
            allocated_ingredients: ingredients
        };
        
        this.renderMealCard(day, this.mealPlan.meals[day]);
        this.updateIngredientPool();
        this.saveMealPlan();
    }
}

// Initialize and export
const mealPlanner = new MealPlanner();

// Export static methods for onclick handlers
window.MealPlanner = {
    regenerateMeal: (day) => mealPlanner.regenerateMeal(day),
    lockMeal: (day) => mealPlanner.lockMeal(day),
    removeMeal: (day) => mealPlanner.removeMeal(day),
    changeWeek: (direction) => mealPlanner.changeWeek(direction),
    instance: mealPlanner
};

export default mealPlanner;